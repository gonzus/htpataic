<!DOCTYPE html>
<html>
<head>
<title>15. Light and dark</title>
<link rel="stylesheet" href="htpataic.css" type="text/css" />
</head>
<body>
<table class="contents"><tr><td>
<h4>Contents</h4>
<div><a href="htpataic01.html">1. Introduction</a></div>
<div><a href="htpataic02.html">2. The main loop</a></div>
<div><a href="htpataic03.html">3. Locations</a></div>
<div><a href="htpataic04.html">4. Objects</a></div>
<div><a href="htpataic05.html">5. Inventory</a></div>
<div><a href="htpataic06.html">6. Passages</a></div>
<div><a href="htpataic07.html">7. Distance</a></div>
<div><a href="htpataic08.html">8. North, east, south, west</a></div>
<div><a href="htpataic09.html">9. Code generation</a></div>
<div><a href="htpataic10.html">10. More attributes</a></div>
<div><a href="htpataic11.html">11. Conditions</a></div>
<div><a href="htpataic12.html">12. Open and close</a></div>
<div><a href="htpataic13.html">13. The parser</a></div>
<div><a href="htpataic14.html">14. Multiple nouns</a></div>
<div><b>15. Light and dark</b></div>
<div><a href="htpataic16.html">16. Savegame</a></div>
<div><a href="htpataic17.html">17. Test automation</a></div>
<div><a href="htpataic18.html">18. Abbreviations</a></div>
<div><a href="htpataic19.html">19. Conversations</a></div>
<div><a href="htpataic20.html">20. Combat</a></div>
<div><a href="htpataic21.html">21. Multi-player</a></div>
<div><a href="htpataic22.html">22. Client-server</a></div>
<div><a href="htpataic23.html">23. Database</a></div>
<div><a href="htpataic24.html">24. Speech</a></div>
<div><a href="htpataic25.html">25. JavaScript</a></div>
</td></tr></table>

<h1>How to program a text adventure in C</h1>
<p>
by Ruud Helderman
&lt;<a href="mailto:r.helderman@hccnet.nl">r.helderman@hccnet.nl</a>&gt;
</p>
<p>
Licensed under
<a href="https://github.com/helderman/htpataic/blob/master/LICENSE">MIT License</a>
</p>
<h2>15. Light and dark</h2>
<p class="intro">
In many adventures, a lamp is a vital object.
Without it, you cannot make it through the dark caverns that lie ahead.
</p>
<p>
The effect of being in the dark differs from game to game.
Typically, it makes the command &lsquo;look&rsquo; ineffective.
In some games (e.g. <a href="https://en.wikipedia.org/wiki/Zork">Zork</a>),
darkness is deadly.
In others, you can still make progress without a light source,
provided you have drawn a detailed map of the dark area.
</p>
<p>
Our game will stay in between;
being in the dark will not get you killed,
but you will not be able to follow any passages either.
An exception will be made for passages that lead back into the light;
it seemed unfair to me to allow the player to run into a dark area,
without an opportunity to get back to where he came from.
</p>
<p>
Alright; so first of all, in darkness you cannot see your surroundings.
</p>
<table class="code"><tr>
<th>location.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old">#include "match.h"</li>
<li class="old">#include "noun.h"</li>
<li class="old"></li>
<li class="old">bool executeLookAround(void)</li>
<li class="old">{</li>
<li class="new"><span class="old">   </span>if (isLit(player-&gt;location))</li>
<li class="new">   {</li>
<li class="old">      printf("You are in %s.\n", player-&gt;location-&gt;description);</li>
<li class="new"><span class="old">   </span>}</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("It is very dark in here.\n");</li>
<li class="new">   }</li>
<li class="old">   listObjectsAtLocation(player-&gt;location);</li>
<li class="old">   return true;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">bool executeLook(void)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = getVisible("what you want to look at", params[0]);</li>
<li class="old">   switch (getDistance(player, obj))</li>
<li class="old">   {</li>
<li class="old">   case distHereContained:</li>
<li class="old">      printf("Hard to see, try to get it first.\n");</li>
<li class="old">      break;</li>
<li class="old">   case distOverthere:</li>
<li class="old">      printf("Too far away, move closer please.\n");</li>
<li class="old">      break;</li>
<li class="old">   case distNotHere:</li>
<li class="old">      printf("You don't see any %s here.\n", params[0]);</li>
<li class="old">      break;</li>
<li class="old">   case distUnknownObject:</li>
<li class="old">      // already handled by getVisible</li>
<li class="old">      break;</li>
<li class="old">   default:</li>
<li class="old">      printf("%s\n", obj-&gt;details);</li>
<li class="old">      listObjectsAtLocation(obj);</li>
<li class="old">   }</li>
<li class="old">   return true;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static void movePlayer(OBJECT *passage)</li>
<li class="old">{</li>
<li class="old">   printf("%s\n", passage-&gt;textGo);</li>
<li class="old">   if (passage-&gt;destination != NULL)</li>
<li class="old">   {</li>
<li class="old">      player-&gt;location = passage-&gt;destination;</li>
<li class="old">      printf("\n");</li>
<li class="old">      executeLookAround();</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">bool executeGo(void)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = getVisible("where you want to go", params[0]);</li>
<li class="old">   switch (getDistance(player, obj))</li>
<li class="old">   {</li>
<li class="old">   case distOverthere:</li>
<li class="old">      movePlayer(getPassage(player-&gt;location, obj));</li>
<li class="old">      break;</li>
<li class="old">   case distNotHere:</li>
<li class="old">      printf("You don't see any %s here.\n", params[0]);</li>
<li class="old">      break;</li>
<li class="old">   case distUnknownObject:</li>
<li class="old">      // already handled by getVisible</li>
<li class="old">      break;</li>
<li class="old">   default:</li>
<li class="old">      movePlayer(obj);</li>
<li class="old">   }</li>
<li class="old">   return true;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
Secondly, in darkness you cannot see or use nearby objects.
</p>
<table class="code"><tr>
<th>noun.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include &lt;string.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old"></li>
<li class="old">static bool objectHasTag(OBJECT *obj, const char *noun)</li>
<li class="old">{</li>
<li class="old">   if (noun != NULL &amp;&amp; *noun != '\0')</li>
<li class="old">   {</li>
<li class="old">      const char **tag;</li>
<li class="old">      for (tag = obj-&gt;tags; *tag != NULL; tag++)</li>
<li class="old">      {</li>
<li class="old">         if (strcmp(*tag, noun) == 0) return true;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return false;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static OBJECT ambiguousNoun;</li>
<li class="old"></li>
<li class="old">static OBJECT *getObject(const char *noun, OBJECT *from, DISTANCE maxDistance)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj, *res = NULL;</li>
<li class="old">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="old">   {</li>
<li class="old">      if (objectHasTag(obj, noun) &amp;&amp; getDistance(from, obj) &lt;= maxDistance)</li>
<li class="old">      {</li>
<li class="old">         res = res == NULL ? obj : &amp;ambiguousNoun;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return res;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">OBJECT *getVisible(const char *intention, const char *noun)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = getObject(noun, player, distOverthere);</li>
<li class="old">   if (obj == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (getObject(noun, player, distNotHere) == NULL)</li>
<li class="old">      {</li>
<li class="old">         printf("I don't understand %s.\n", intention);</li>
<li class="old">      }</li>
<li class="new"><span class="old">      else </span>if (isLit(player-&gt;location))</li>
<li class="old">      {</li>
<li class="old">         printf("You don't see any %s here.\n", noun);</li>
<li class="new"><span class="old">      </span>}</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         printf("It's too dark.\n");</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (obj == &amp;ambiguousNoun)</li>
<li class="old">   {</li>
<li class="old">      printf("Please be specific about which %s you mean.\n", noun);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   return obj;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = NULL;</li>
<li class="old">   if (from == NULL)</li>
<li class="old">   {</li>
<li class="old">      printf("I don't understand who you want to %s.\n", verb);</li>
<li class="old">   }</li>
<li class="old">   else if ((obj = getObject(noun, from, distHeldContained)) == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (getObject(noun, player, distNotHere) == NULL)</li>
<li class="old">      {</li>
<li class="old">         printf("I don't understand what you want to %s.\n", verb);</li>
<li class="old">      }</li>
<li class="old">      else if (from == player)</li>
<li class="old">      {</li>
<li class="old">         printf("You are not holding any %s.\n", noun);</li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         printf("There appears to be no %s you can get from %s.\n",</li>
<li class="old">                noun, from-&gt;description);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (obj == &amp;ambiguousNoun)</li>
<li class="old">   {</li>
<li class="old">      printf("Please be specific about which %s you want to %s.\n",</li>
<li class="old">             noun, verb);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   else if (obj == from)</li>
<li class="old">   {</li>
<li class="old">      printf("You should not be doing that to %s.\n", obj-&gt;description);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   return obj;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
In both cases, we used a function <i>isLit</i>.
It is defined (and used some more) in <i>misc.c</i>.
</p>
<table class="code"><tr>
<th>misc.h</th>
</tr><tr>
<td>
<ol>
<li class="old">typedef enum {</li>
<li class="old">   distSelf,</li>
<li class="old">   distHeld,</li>
<li class="old">   distHeldContained,</li>
<li class="old">   distLocation,</li>
<li class="old">   distHere,</li>
<li class="old">   distHereContained,</li>
<li class="old">   distOverthere,</li>
<li class="old">   distNotHere,</li>
<li class="old">   distUnknownObject</li>
<li class="old">} DISTANCE;</li>
<li class="old"></li>
<li class="old">extern bool isHolding(OBJECT *container, OBJECT *obj);</li>
<li class="new">extern bool isLit(OBJECT *location);</li>
<li class="old">extern OBJECT *getPassage(OBJECT *from, OBJECT *to);</li>
<li class="old">extern DISTANCE getDistance(OBJECT *from, OBJECT *to);</li>
<li class="old">extern OBJECT *actorHere(void);</li>
<li class="old">extern int listObjectsAtLocation(OBJECT *location);</li>
</ol>
</td>
</tr><tr>
<th>misc.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old"></li>
<li class="old">bool isHolding(OBJECT *container, OBJECT *obj)</li>
<li class="old">{</li>
<li class="old">   return validObject(obj) &amp;&amp; obj-&gt;location == container;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="new">bool isLit(OBJECT *target)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj;</li>
<li class="new">   if (validObject(target))</li>
<li class="new">   {</li>
<li class="new">      if (target-&gt;light &gt; 0)</li>
<li class="new">      {</li>
<li class="new">         return true;</li>
<li class="new">      }</li>
<li class="new">      for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">      {</li>
<li class="new">         if (validObject(obj) &amp;&amp; obj-&gt;light &gt; 0 &amp;&amp;</li>
<li class="new">             (isHolding(target, obj) || isHolding(target, obj-&gt;location)))</li>
<li class="new">         {</li>
<li class="new">            return true;</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return false;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static bool isIlluminated(OBJECT *obj)</li>
<li class="new">{</li>
<li class="new">   return isLit(obj) || isLit(obj-&gt;prospect) || isLit(player-&gt;location);</li>
<li class="new">}</li>
<li class="old"></li>
<li class="old">OBJECT *getPassage(OBJECT *from, OBJECT *to)</li>
<li class="old">{</li>
<li class="old">   if (from != NULL &amp;&amp; to != NULL)</li>
<li class="old">   {</li>
<li class="old">      OBJECT *obj;</li>
<li class="old">      for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="old">      {</li>
<li class="old">         if (isHolding(from, obj) &amp;&amp; obj-&gt;prospect == to)</li>
<li class="old">         {</li>
<li class="old">            return obj;</li>
<li class="old">         }</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return NULL;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">DISTANCE getDistance(OBJECT *from, OBJECT *to)</li>
<li class="old">{</li>
<li class="old">   return to == NULL                               ? distUnknownObject :</li>
<li class="old">          !validObject(to)                         ? distNotHere :</li>
<li class="old">          to == from                               ? distSelf :</li>
<li class="old">          isHolding(from, to)                      ? distHeld :</li>
<li class="new"><span class="old">          </span>!isIlluminated(to)                       ? distNotHere :</li>
<li class="old">          isHolding(to, from)                      ? distLocation :</li>
<li class="old">          isHolding(from-&gt;location, to)            ? distHere :</li>
<li class="old">          isHolding(from, to-&gt;location)            ? distHeldContained :</li>
<li class="old">          isHolding(from-&gt;location, to-&gt;location)  ? distHereContained :</li>
<li class="old">          getPassage(from-&gt;location, to) != NULL   ? distOverthere :</li>
<li class="old">                                                     distNotHere;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">OBJECT *actorHere(void)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj;</li>
<li class="old">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="old">   {</li>
<li class="old">      if (isHolding(player-&gt;location, obj) &amp;&amp; obj != player &amp;&amp;</li>
<li class="new"><span class="old">          </span>isIlluminated(obj) &amp;&amp;<span class="old"> obj-&gt;health &gt; 0)</span></li>
<li class="old">      {</li>
<li class="old">         return obj;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return NULL;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">int listObjectsAtLocation(OBJECT *location)</li>
<li class="old">{</li>
<li class="old">   int count = 0;</li>
<li class="old">   OBJECT *obj;</li>
<li class="old">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="old">   {</li>
<li class="new"><span class="old">      if (obj != player &amp;&amp; isHolding(location, </span>obj) &amp;&amp; isIlluminated(obj))</li>
<li class="old">      {</li>
<li class="old">         if (count++ == 0)</li>
<li class="old">         {</li>
<li class="old">            printf("%s:\n", location-&gt;contents);</li>
<li class="old">         }</li>
<li class="old">         printf("%s\n", obj-&gt;description);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return count;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 11-30:
<i>isLit</i> will be used to check if a given location is light or dark.
Note: it is not enough to simply check attribute <i>light</i> of the location;
the location could be lit by a lamp.
</li>
<li>Line 32-35:
<i>isIlluminated</i> takes it one step further;
it works for every object, not just locations and lamps.
</li>
<li>Line 59:
nearby objects that remain hidden in the dark,
are being treated as &lsquo;not here&rsquo;.
This naturally prevents the game from leaking information
about objects the player is not supposed to be aware of.
</li>
</ul>
</div>
<p>
The implementation of <i>isLit</i> uses a new attribute <i>light</i>.
</p>
<table class="code"><tr>
<th>object.awk</th>
</tr><tr>
<td>
<ol>
<li class="old">BEGIN {</li>
<li class="old">   count = 0;</li>
<li class="old">   obj = "";</li>
<li class="old">   if (pass == "c2") {</li>
<li class="old">      print "\nstatic bool alwaysTrue(void) { return true; }";</li>
<li class="old">      print "\nOBJECT objs[] = {";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">/^- / {</li>
<li class="old">   outputRecord(",");</li>
<li class="old">   obj = $2;</li>
<li class="old">   prop["condition"]   = "alwaysTrue";</li>
<li class="old">   prop["description"] = "NULL";</li>
<li class="old">   prop["tags"]        = "";</li>
<li class="old">   prop["location"]    = "NULL";</li>
<li class="old">   prop["destination"] = "NULL";</li>
<li class="old">   prop["prospect"]    = "";</li>
<li class="old">   prop["details"]     = "\"You see nothing special.\"";</li>
<li class="old">   prop["contents"]    = "\"You see\"";</li>
<li class="old">   prop["textGo"]      = "\"You can't get much closer than this.\"";</li>
<li class="old">   prop["weight"]      = "99";</li>
<li class="old">   prop["capacity"]    = "0";</li>
<li class="old">   prop["health"]      = "0";</li>
<li class="new">   prop["light"]       = "0";</li>
<li class="old">   prop["open"]        = "cannotBeOpened";</li>
<li class="old">   prop["close"]       = "cannotBeClosed";</li>
<li class="old">   prop["lock"]        = "cannotBeLocked";</li>
<li class="old">   prop["unlock"]      = "cannotBeUnlocked";</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">obj &amp;&amp; /^[ \t]+[a-z]/ {</li>
<li class="old">   name = $1;</li>
<li class="old">   $1 = "";</li>
<li class="old">   if (name in prop) {</li>
<li class="old">      prop[name] = $0;</li>
<li class="old">      if (/^[ \t]*\{/) {</li>
<li class="old">         prop[name] = name count;</li>
<li class="old">         if (pass == "c1") print "static bool " prop[name] "(void) " $0;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (pass == "c2") {</li>
<li class="old">      print "#error \"" FILENAME " line " NR ": unknown attribute '" name "'\"";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">!obj &amp;&amp; pass == (/^#include/ ? "c1" : "h") {</li>
<li class="old">   print;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">END {</li>
<li class="old">   outputRecord("\n};");</li>
<li class="old">   if (pass == "h") {</li>
<li class="old">      print "\n#define endOfObjs\t(objs + " count ")";</li>
<li class="old">      print "\n#define validObject(obj)\t" \</li>
<li class="old">            "((obj) != NULL &amp;&amp; (*(obj)-&gt;condition)())";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">function outputRecord(separator)</li>
<li class="old">{</li>
<li class="old">   if (obj) {</li>
<li class="old">      if (pass == "h") {</li>
<li class="old">         print "#define " obj "\t(objs + " count ")";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c1") {</li>
<li class="old">         print "static const char *tags" count "[] = {" prop["tags"] ", NULL};";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c2") {</li>
<li class="old">         print "\t{\t/* " count " = " obj " */";</li>
<li class="old">         print "\t\t" prop["condition"] ",";</li>
<li class="old">         print "\t\t" prop["description"] ",";</li>
<li class="old">         print "\t\ttags" count ",";</li>
<li class="old">         print "\t\t" prop["location"] ",";</li>
<li class="old">         print "\t\t" prop["destination"] ",";</li>
<li class="old">         print "\t\t" prop[prop["prospect"] ? "prospect" : "destination"] ",";</li>
<li class="old">         print "\t\t" prop["details"] ",";</li>
<li class="old">         print "\t\t" prop["contents"] ",";</li>
<li class="old">         print "\t\t" prop["textGo"] ",";</li>
<li class="old">         print "\t\t" prop["weight"] ",";</li>
<li class="old">         print "\t\t" prop["capacity"] ",";</li>
<li class="old">         print "\t\t" prop["health"] ",";</li>
<li class="new">         print "\t\t" prop["light"] ",";</li>
<li class="old">         print "\t\t" prop["open"] ",";</li>
<li class="old">         print "\t\t" prop["close"] ",";</li>
<li class="old">         print "\t\t" prop["lock"] ",";</li>
<li class="old">         print "\t\t" prop["unlock"];</li>
<li class="old">         print "\t}" separator;</li>
<li class="old">         delete prop;</li>
<li class="old">      }</li>
<li class="old">      count++;</li>
<li class="old">   }</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
By default, <i>light</i> is zero, meaning an object does not emit light.
Every location in broad daylight (typically all but the underground ones)
will be given a positive <i>light</i> value.
It doesn&rsquo;t really matter what value that is; as long as it&rsquo;s not zero.
We will also add a lamp the player can carry to traverse dark areas.
</p>
<table class="code"><tr>
<th>object.txt</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "toggle.h"</li>
<li class="old"></li>
<li class="old">typedef struct object {</li>
<li class="old">   bool         (*condition)(void);</li>
<li class="old">   const char    *description;</li>
<li class="old">   const char   **tags;</li>
<li class="old">   struct object *location;</li>
<li class="old">   struct object *destination;</li>
<li class="old">   struct object *prospect;</li>
<li class="old">   const char    *details;</li>
<li class="old">   const char    *contents;</li>
<li class="old">   const char    *textGo;</li>
<li class="old">   int            weight;</li>
<li class="old">   int            capacity;</li>
<li class="old">   int            health;</li>
<li class="new">   int            light;</li>
<li class="old">   void         (*open)(void);</li>
<li class="old">   void         (*close)(void);</li>
<li class="old">   void         (*lock)(void);</li>
<li class="old">   void         (*unlock)(void);</li>
<li class="old">} OBJECT;</li>
<li class="old"></li>
<li class="old">extern OBJECT objs[];</li>
<li class="old"></li>
<li class="old">- field</li>
<li class="old">     description "an open field"</li>
<li class="old">     tags        "field"</li>
<li class="old">     details     "The field is a nice and quiet place under a clear blue sky."</li>
<li class="old">     capacity    9999</li>
<li class="new">     light       100</li>
<li class="old"></li>
<li class="old">- cave</li>
<li class="old">     description "a little cave"</li>
<li class="old">     tags        "cave"</li>
<li class="old">     details     "The cave is just a cold, damp, rocky chamber."</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- silver</li>
<li class="old">     description "a silver coin"</li>
<li class="old">     tags        "silver", "coin", "silver coin"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The coin has an eagle on the obverse."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- gold</li>
<li class="old">     description "a gold coin"</li>
<li class="old">     tags        "gold", "coin", "gold coin"</li>
<li class="old">     location    openBox</li>
<li class="old">     details     "The shiny coin seems to be a rare and priceless artefact."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- guard</li>
<li class="old">     description "a burly guard"</li>
<li class="old">     tags        "guard", "burly guard"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The guard is a really big fellow."</li>
<li class="old">     contents    "He has"</li>
<li class="old">     health      100</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- player</li>
<li class="old">     description "yourself"</li>
<li class="old">     tags        "yourself"</li>
<li class="old">     location    field</li>
<li class="old">     details     "You would need a mirror to look at yourself."</li>
<li class="old">     contents    "You have"</li>
<li class="old">     health      100</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- intoCave</li>
<li class="old">     condition   { return guard-&gt;health == 0 || silver-&gt;location == guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop."</li>
<li class="old">     textGo      "You walk into the cave."</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- intoCaveBlocked</li>
<li class="old">     condition   { return guard-&gt;health &gt; 0 &amp;&amp; silver-&gt;location != guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop."</li>
<li class="old">     textGo      "The guard stops you from walking into the cave."</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- exitCave</li>
<li class="old">     description "an exit to the west"</li>
<li class="old">     tags        "west", "exit"</li>
<li class="old">     location    cave</li>
<li class="old">     destination field</li>
<li class="old">     details     "Sunlight pours in through an opening in the cave's wall."</li>
<li class="old">     textGo      "You walk out of the cave."</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- wallField</li>
<li class="old">     description "dense forest all around"</li>
<li class="old">     tags        "west", "north", "south", "forest"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The field is surrounded by trees and undergrowth."</li>
<li class="old">     textGo      "Dense forest is blocking the way."</li>
<li class="old"></li>
<li class="old">- wallCave</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "north", "rock"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "Carved in stone is a secret password 'abccb'."</li>
<li class="old">     textGo      "Solid rock is blocking the way."</li>
<li class="old"></li>
<li class="old">- backroom</li>
<li class="old">     description "a backroom"</li>
<li class="old">     tags        "backroom"</li>
<li class="old">     details     "The room is dusty and messy."</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- wallBackroom</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "west", "south", "rock"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "Trendy wallpaper covers the rock walls."</li>
<li class="old">     textGo      "Solid rock is blocking the way."</li>
<li class="old"></li>
<li class="old">- openDoorToBackroom</li>
<li class="old">     description "an open door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     destination backroom</li>
<li class="old">     details     "The door is open."</li>
<li class="old">     textGo      "You walk through the door into a backroom."</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleDoorToBackroom</li>
<li class="old"></li>
<li class="old">- closedDoorToBackroom</li>
<li class="old">     description "a closed door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     location    cave</li>
<li class="old">     prospect    backroom</li>
<li class="old">     details     "The door is closed."</li>
<li class="old">     textGo      "The door is closed."</li>
<li class="old">     open        toggleDoorToBackroom</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openDoorToCave</li>
<li class="old">     description "an open door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The door is open."</li>
<li class="old">     textGo      "You walk through the door into the cave."</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleDoorToCave</li>
<li class="old"></li>
<li class="old">- closedDoorToCave</li>
<li class="old">     description "a closed door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     location    backroom</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The door is closed."</li>
<li class="old">     textGo      "The door is closed."</li>
<li class="old">     open        toggleDoorToCave</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is open."</li>
<li class="old">     weight      5</li>
<li class="old">     capacity    10</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleBox</li>
<li class="old">     lock        isStillOpen</li>
<li class="old">     unlock      isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- closedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is closed."</li>
<li class="old">     weight      5</li>
<li class="old">     open        toggleBox</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        toggleBoxLock</li>
<li class="old">     unlock      isAlreadyUnlocked</li>
<li class="old"></li>
<li class="old">- lockedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "The box is closed."</li>
<li class="old">     weight      5</li>
<li class="old">     open        isStillLocked</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        isAlreadyLocked</li>
<li class="old">     unlock      toggleBoxLock</li>
<li class="old"></li>
<li class="old">- keyForBox</li>
<li class="old">     description "a tiny key"</li>
<li class="old">     tags        "key", "tiny key"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "The key is really small and shiny."</li>
<li class="old">     weight      1</li>
<li class="new"></li>
<li class="new">- lampOff</li>
<li class="new">     description "a lamp"</li>
<li class="new">     tags        "lamp"</li>
<li class="new">     location    field</li>
<li class="new">     details     "The lamp is off."</li>
<li class="new">     weight      5</li>
<li class="new"></li>
<li class="new">- lampOn</li>
<li class="new">     description "a lamp"</li>
<li class="new">     tags        "lamp"</li>
<li class="new">     details     "The lamp is on."</li>
<li class="new">     weight      5</li>
<li class="new">     light       100</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 19:
the new attribute.
</li>
<li>Line 33:
so far, the field is the only location with &lsquo;natural&rsquo; light.
</li>
<li>Line 206-218:
for the lamp we actually have two objects:
the lamp being off and the lamp being on.
But the player will only get to see one at a time;
together they act as a single item.
</li>
</ul>
</div>
<p>
We will add some commands we can use to turn the lamp on and off.
</p>
<table class="code"><tr>
<th>parsexec.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;ctype.h&gt;</li>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old">#include "match.h"</li>
<li class="old">#include "location.h"</li>
<li class="old">#include "inventory.h"</li>
<li class="old">#include "inventory2.h"</li>
<li class="old">#include "openclose.h"</li>
<li class="new">#include "onoff.h"</li>
<li class="old"></li>
<li class="old">typedef struct</li>
<li class="old">{</li>
<li class="old">   const char *pattern;</li>
<li class="old">   bool (*function)(void);</li>
<li class="old">} COMMAND;</li>
<li class="old"></li>
<li class="old">static bool executeQuit(void)</li>
<li class="old">{</li>
<li class="old">   return false;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool executeNoMatch(void)</li>
<li class="old">{</li>
<li class="old">   const char *src = *params;</li>
<li class="old">   int len;</li>
<li class="old">   for (len = 0; src[len] != '\0' &amp;&amp; !isspace(src[len]); len++);</li>
<li class="old">   if (len &gt; 0) printf("I don't know how to '%.*s'.\n", len, src);</li>
<li class="old">   return true;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">bool parseAndExecute(const char *input)</li>
<li class="old">{</li>
<li class="old">   static const COMMAND commands[] =</li>
<li class="old">   {</li>
<li class="old">      { "quit"                , executeQuit       },</li>
<li class="old">      { "look"                , executeLookAround },</li>
<li class="old">      { "look around"         , executeLookAround },</li>
<li class="old">      { "look at A"           , executeLook       },</li>
<li class="old">      { "look A"              , executeLook       },</li>
<li class="old">      { "examine A"           , executeLook       },</li>
<li class="old">      { "go to A"             , executeGo         },</li>
<li class="old">      { "go A"                , executeGo         },</li>
<li class="old">      { "get A from B"        , executeGetFrom    },</li>
<li class="old">      { "get A"               , executeGet        },</li>
<li class="old">      { "put A in B"          , executePutIn      },</li>
<li class="old">      { "drop A in B"         , executePutIn      },</li>
<li class="old">      { "drop A"              , executeDrop       },</li>
<li class="old">      { "ask A from B"        , executeAskFrom    },</li>
<li class="old">      { "ask A"               , executeAsk        },</li>
<li class="old">      { "give A to B"         , executeGiveTo     },</li>
<li class="old">      { "give A"              , executeGive       },</li>
<li class="old">      { "inventory"           , executeInventory  },</li>
<li class="old">      { "open A"              , executeOpen       },</li>
<li class="old">      { "close A"             , executeClose      },</li>
<li class="old">      { "lock A"              , executeLock       },</li>
<li class="old">      { "unlock A"            , executeUnlock     },</li>
<li class="new">      { "turn on A"           , executeTurnOn     },</li>
<li class="new">      { "turn off A"          , executeTurnOff    },</li>
<li class="new">      { "turn A on"           , executeTurnOn     },</li>
<li class="new">      { "turn A off"          , executeTurnOff    },</li>
<li class="old">      { "A"                   , executeNoMatch    }</li>
<li class="old">   };</li>
<li class="old">   const COMMAND *cmd;</li>
<li class="old">   for (cmd = commands; !matchCommand(input, cmd-&gt;pattern); cmd++);</li>
<li class="old">   return (*cmd-&gt;function)();</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
Below is the implementation of these commands.
</p>
<table class="demo">
<tr><th>Sample output</th></tr>
<tr><td>
Welcome to Little Cave Adventure.<br />
You are in an open field.<br />
You see:<br />
a silver coin<br />
a burly guard<br />
a cave entrance to the east<br />
dense forest all around<br />
a lamp<br />
<br />
--&gt; get lamp<br />
You pick up a lamp.<br />
<br />
--&gt; get coin<br />
You pick up a silver coin.<br />
<br />
--&gt; give coin<br />
You give a silver coin to a burly guard.<br />
<br />
--&gt; go cave<br />
You walk into the cave.<br />
<br />
It is very dark in here.<br />
You see:<br />
an exit to the west<br />
<br />
--&gt; get key<br />
It's too dark.<br />
<br />
--&gt; open door<br />
It's too dark.<br />
<br />
--&gt; go south<br />
It's too dark.<br />
<br />
--&gt; turn lamp on<br />
You turn on a lamp.<br />
<br />
You are in a little cave.<br />
You see:<br />
an exit to the west<br />
solid rock all around<br />
a closed door to the south<br />
a tiny key<br />
<br />
--&gt; look around<br />
You are in a little cave.<br />
You see:<br />
an exit to the west<br />
solid rock all around<br />
a closed door to the south<br />
a tiny key<br />
<br />
--&gt; get key<br />
You pick up a tiny key.<br />
<br />
--&gt; open door<br />
You open a closed door to the south.<br />
<br />
--&gt; go south<br />
You walk through the door into a backroom.<br />
<br />
You are in a backroom.<br />
You see:<br />
solid rock all around<br />
an open door to the north<br />
a wooden box<br />
<br />
--&gt; quit<br />
<br />
Bye!<br />
</td></tr>
</table>
<table class="code"><tr>
<th>onoff.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern bool executeTurnOn(void);</li>
<li class="new">extern bool executeTurnOff(void);</li>
</ol>
</td>
</tr><tr>
<th>onoff.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "match.h"</li>
<li class="new">#include "reach.h"</li>
<li class="new">#include "toggle.h"</li>
<li class="new"></li>
<li class="new">bool executeTurnOn(void)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj = reachableObject("what you want to turn on", params[0]);</li>
<li class="new">   if (obj != NULL)</li>
<li class="new">   {</li>
<li class="new">      if (obj == lampOff)</li>
<li class="new">      {</li>
<li class="new">         toggleLamp();</li>
<li class="new">      }</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         printf(obj == lampOn ? "The lamp is already on.\n"</li>
<li class="new">                              : "You cannot turn that on.\n");</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return true;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool executeTurnOff(void)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj = reachableObject("what you want to turn off", params[0]);</li>
<li class="new">   if (obj != NULL)</li>
<li class="new">   {</li>
<li class="new">      if (obj == lampOn)</li>
<li class="new">      {</li>
<li class="new">         toggleLamp();</li>
<li class="new">      }</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         printf(obj == lampOff ? "The lamp is already off.\n"</li>
<li class="new">                               : "You cannot turn that off.\n");</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return true;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<p>
To turn the lamp on and off,
we will use the same trick we used to open and close the door and the box
(see chapter 12).
</p>
<table class="code"><tr>
<th>toggle.h</th>
</tr><tr>
<td>
<ol>
<li class="old">extern void cannotBeOpened(void);</li>
<li class="old">extern void cannotBeClosed(void);</li>
<li class="old">extern void cannotBeLocked(void);</li>
<li class="old">extern void cannotBeUnlocked(void);</li>
<li class="old"></li>
<li class="old">extern void isAlreadyOpen(void);</li>
<li class="old">extern void isAlreadyClosed(void);</li>
<li class="old">extern void isAlreadyLocked(void);</li>
<li class="old">extern void isAlreadyUnlocked(void);</li>
<li class="old"></li>
<li class="old">extern void isStillOpen(void);</li>
<li class="old">extern void isStillLocked(void);</li>
<li class="old"></li>
<li class="old">extern void toggleDoorToBackroom(void);</li>
<li class="old">extern void toggleDoorToCave(void);</li>
<li class="old">extern void toggleBox(void);</li>
<li class="old">extern void toggleBoxLock(void);</li>
<li class="new"></li>
<li class="new">extern void toggleLamp(void);</li>
</ol>
</td>
</tr><tr>
<th>toggle.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="new">#include "misc.h"</li>
<li class="new">#include "location.h"</li>
<li class="old"></li>
<li class="old">static void swapLocations(const char *verb1, OBJECT *obj1,</li>
<li class="old">                          const char *verb2, OBJECT *obj2)</li>
<li class="old">{</li>
<li class="old">   OBJECT *tmp = obj1-&gt;location;</li>
<li class="old">   OBJECT *obj = tmp != NULL ? obj1 : obj2;</li>
<li class="old">   const char *verb = tmp != NULL ? verb1 : verb2;</li>
<li class="old">   obj1-&gt;location = obj2-&gt;location;</li>
<li class="old">   obj2-&gt;location = tmp;</li>
<li class="old">   if (verb != NULL) printf("You %s %s.\n", verb, obj-&gt;description);</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">void cannotBeOpened(void)    { printf("That cannot be opened.\n");    }</li>
<li class="old">void cannotBeClosed(void)    { printf("That cannot be closed.\n");    }</li>
<li class="old">void cannotBeLocked(void)    { printf("That cannot be locked.\n");    }</li>
<li class="old">void cannotBeUnlocked(void)  { printf("That cannot be unlocked.\n");  }</li>
<li class="old"></li>
<li class="old">void isAlreadyOpen(void)     { printf("That is already open.\n");     }</li>
<li class="old">void isAlreadyClosed(void)   { printf("That is already closed.\n");   }</li>
<li class="old">void isAlreadyLocked(void)   { printf("That is already locked.\n");   }</li>
<li class="old">void isAlreadyUnlocked(void) { printf("That is already unlocked.\n"); }</li>
<li class="old"></li>
<li class="old">void isStillOpen(void)       { printf("That is still open.\n");       }</li>
<li class="old">void isStillLocked(void)     { printf("That is locked.\n");           }</li>
<li class="old"></li>
<li class="old">void toggleDoorToBackroom(void)</li>
<li class="old">{</li>
<li class="old">   swapLocations(NULL, openDoorToCave, NULL, closedDoorToCave);</li>
<li class="old">   swapLocations("close", openDoorToBackroom, "open", closedDoorToBackroom);</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">void toggleDoorToCave(void)</li>
<li class="old">{</li>
<li class="old">   swapLocations(NULL, openDoorToBackroom, NULL, closedDoorToBackroom);</li>
<li class="old">   swapLocations("close", openDoorToCave, "open", closedDoorToCave);</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">void toggleBox(void)</li>
<li class="old">{</li>
<li class="old">   swapLocations("close", openBox, "open", closedBox);</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">void toggleBoxLock(void)</li>
<li class="old">{</li>
<li class="old">   if (keyForBox-&gt;location == player)</li>
<li class="old">   {</li>
<li class="old">      swapLocations("lock", closedBox, "unlock", lockedBox);</li>
<li class="old">   }</li>
<li class="old">   else</li>
<li class="old">   {</li>
<li class="old">      printf("You don't have a key.\n");</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void toggleLamp(void)</li>
<li class="new">{</li>
<li class="new">   bool oldLit = isLit(player-&gt;location);</li>
<li class="new">   swapLocations("turn off", lampOn, "turn on", lampOff);</li>
<li class="new">   if (oldLit != isLit(player-&gt;location))</li>
<li class="new">   {</li>
<li class="new">      printf("\n");</li>
<li class="new">      executeLookAround();</li>
<li class="old">   }</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 63:
we are doing the exact same trick
as used in chapter 12 to open and close objects.
Just swap between two different objects:
one for the lamp turned on, the other for the lamp turned off.
</li>
<li>Lines 64-68:
when turning on the light in a dark area,
we immediately give players a look at their surroundings.
This is consistent with the behavior of the &lsquo;go&rsquo; command:
the moment you set eyes on a location,
&lsquo;look around&rsquo; is automatically executed.
You may notice we are doing the same here when turning the light <i>off</i>.
Obviously this will return little more than
&ldquo;it is very dark in here&rdquo;,
but that too seems like a relevant observation.
So since we are doing a &lsquo;look around&rsquo; either way,
what is the point of the &lsquo;if&rsquo; statement?
Well, that prevents a useless &lsquo;look around&rsquo;
when turning the lamp on or off in broad daylight (i.e. in the field),
or with any other source of light still active in the same room.
</li>
</ul>
</div>
<img class="genmap" src="code15/map.png" />
<p>
Finally, we will mark the dark locations in our generated map.
</p>
<table class="code"><tr>
<th>map.awk</th>
</tr><tr>
<td>
<ol>
<li class="new"><span class="old">BEGIN     { print "digraph map </span>{\n\tnode [style=filled]";<span class="old"> }</span></li>
<li class="new"><span class="old">/^- /     { outputEdges(); </span>obj = $2;<span class="old"> delete a; }</span></li>
<li class="old">/^[ \t]/  { a[$1] = $2; }</li>
<li class="new"><span class="old">END       { outputEdges(); </span>outputNodes();<span class="old"> print "}"; }</span></li>
<li class="old"></li>
<li class="old">function outputEdges()</li>
<li class="old">{</li>
<li class="new"><span class="old">   </span>color[obj] = a["light"] ? "white" : "grey";</li>
<li class="old">   outputEdge(a["location"], a["destination"], "");</li>
<li class="old">   outputEdge(a["location"], a["prospect"], " [style=dashed]");</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">function outputEdge(from, to, style)</li>
<li class="old">{</li>
<li class="new"><span class="old">   if </span>(to)</li>
<li class="new">   {</li>
<li class="new">      nodes[to] = 1;</li>
<li class="new">      if (from)</li>
<li class="new">      {</li>
<li class="new">         nodes[from] = 1;</li>
<li class="old">         print "\t" from " -&gt; " to style;</li>
<li class="new"><span class="old">      </span>}</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">function outputNodes()</li>
<li class="new">{</li>
<li class="new">   for (n in nodes) print "\t" n " [fillcolor=" color[n] "]";</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
Players, please be careful not to turn off the lamp and drop it.
In the dark, you will never be able to find it back. You will be stuck!
Fortunately, the next chapter will provide a way to undo clumsy actions.
</p>
<hr />
<table class="download"><tr><td>
<a class="button" href="code15/src.zip">&#x2B73; &nbsp; Download source code</a>
<a class="button" href="https://repl.it/github/helderman/htpataic">&#x1F300; &nbsp; Run on Repl.it</a>
</td></tr></table>
<p>
Next chapter: <a href="htpataic16.html">16. Savegame</a>
</p>
</body>
</html>
