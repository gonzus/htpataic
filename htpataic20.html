<!DOCTYPE html>
<html>
<head>
<title>20. Combat</title>
<link rel="stylesheet" href="htpataic.css" type="text/css" />
</head>
<body>
<table class="contents"><tr><td>
<h4>Contents</h4>
<div><a href="htpataic01.html">1. Introduction</a></div>
<div><a href="htpataic02.html">2. The main loop</a></div>
<div><a href="htpataic03.html">3. Locations</a></div>
<div><a href="htpataic04.html">4. Objects</a></div>
<div><a href="htpataic05.html">5. Inventory</a></div>
<div><a href="htpataic06.html">6. Passages</a></div>
<div><a href="htpataic07.html">7. Distance</a></div>
<div><a href="htpataic08.html">8. North, east, south, west</a></div>
<div><a href="htpataic09.html">9. Code generation</a></div>
<div><a href="htpataic10.html">10. More attributes</a></div>
<div><a href="htpataic11.html">11. Conditions</a></div>
<div><a href="htpataic12.html">12. Open and close</a></div>
<div><a href="htpataic13.html">13. The parser</a></div>
<div><a href="htpataic14.html">14. Multiple nouns</a></div>
<div><a href="htpataic15.html">15. Light and dark</a></div>
<div><a href="htpataic16.html">16. Savegame</a></div>
<div><a href="htpataic17.html">17. Test automation</a></div>
<div><a href="htpataic18.html">18. Abbreviations</a></div>
<div><a href="htpataic19.html">19. Conversations</a></div>
<div><b>20. Combat</b></div>
<div><a href="htpataic21.html">21. Database</a></div>
<div><a href="htpataic22.html">22. Speech</a></div>
<div><a href="htpataic23.html">23. JavaScript</a></div>
</td></tr></table>

<h1>How to program a text adventure in C</h1>
<h2>20. Combat</h2>
<p class="intro">
Since the early classics were influenced by
<a href="https://en.wikipedia.org/wiki/Fantasy">fantasy</a>,
it is not surprising that many text-based games adopted elements from
<a href="https://en.wikipedia.org/wiki/Role-playing_game">RPG games</a>
like
<a href="https://en.wikipedia.org/wiki/Dungeons_%26_Dragons">Dungeons &amp; Dragons</a>.
</p>
<p>
Multi-player games thrive on role play and combat; you see that in every
<a href="https://en.wikipedia.org/wiki/MUD">MUD</a>.
Single-player games on the other hand, typically focus on puzzle solving.
The boundaries are not always that sharp.
In the early days, before the rise of
<a href="https://en.wikipedia.org/wiki/Internet">the internet</a>,
there were plenty of single-player games that featured combat,
though often in a simplified form.
</p>
<p>
It is easy enough to implement a &lsquo;kill&rsquo; command that will dispose of any actors standing in your way.
</p>
<table><tr>
<td class="snippet">guard-&gt;health--;    /* do this often enough and he's dead */
</td>
</tr></table>
<p>
But of course there is a lot more to it.
Some weapons may be more effective than others.
Some opponents may be tougher than others.
Both the player and non-player characters stand a better chance in combat
when being healthy, skilled and well-equiped.
A lot can be learned from
<a href="https://en.wikipedia.org/wiki/Tabletop_role-playing_game">tabletop role-playing games</a>,
where
<a href="https://en.wikipedia.org/wiki/Statistic_(role-playing_games)">statistics</a>
determine the chances of survival.
Each stat can be implemented as an attribute in our &lsquo;object&rsquo; structure;
this was discussed in chapter 10.
A combat-related command should use these stats
in a &lsquo;damage formula&rsquo;
that determines the impact of the command on the actors involved.
</p>
<h3>Random</h3>
<p>
Traditionally, some uncertainty is built into such a formula.
Tabletop games have
<a href="https://en.wikipedia.org/wiki/Dice">dice</a>,
computer games have a
<a href="https://en.wikipedia.org/wiki/Random_number_generation">random number generator</a>.
Please note that &lsquo;randomness&rsquo; may cause trouble with the
&lsquo;roll-forward&rsquo; savegame technique proposed in chapter 16.
Roll-forward demands repeatability.
When saving a game, you expect the exact same game state when restoring.
But different random number might completely change
the outcome of battles that took place prior to saving.
</p>
<p>
Fortunately, computers typically use
<a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">Pseudorandom number generators</a>.
Reproducibility is one of their big advantages.
Just make sure to seed the PRNG with the same fixed number at the start of every game.
If you prefer to have a uniquely random game experience for every new game session
(though I doubt that will be relevant for a text adventure,
where a player is typically dedicated to a single ongoing session),
then at least make sure the seed is stored as part of the savegame.
</p>
<h3>Real-time vs turn based</h3>
<p>
When implementing combat in a text adventure,
you will have to choose between
<a href="https://en.wikipedia.org/wiki/Turns,_rounds_and_time-keeping_systems_in_games#Real-time">real-time</a>
and
<a href="https://en.wikipedia.org/wiki/Turns,_rounds_and_time-keeping_systems_in_games#Turn-based">turn-based</a>.
In multi-player games, turn-based only makes sense when playing offline (as in
<a href="https://en.wikipedia.org/wiki/Play-by-mail_game">play-by-mail</a>).
Online players do not want to be kept waiting for other players to respond,
which is why a
<a href="https://en.wikipedia.org/wiki/MUD">MUD</a>
is typically played in real time.
This brings a few coding challenges; in particular
<a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronization</a>.
It&rsquo;s also important to implement some kind of
<a href="https://en.wikipedia.org/wiki/Glossary_of_video_game_terms#cooldown">cooldown</a>,
to prevent things like combat to turn into a
<a href="https://en.wikipedia.org/wiki/Speed_typing_contest">speed typing contest</a>.
</p>
<p>
Single-player games are typically turn-based.
Computers respond faster than humans,
so a human player will not be frustrated by the time it takes
for a non-player character to respond to the player&rsquo;s actions.
Turn-based has the advantage of not rushing players,
giving them all the time in the world to think about their next move,
while at the same time offering instant feedback
at every attempt from the player to solve that seemingly unsolvable problem.
</p>
<p>
Turn-based does not mean there is no notion of time;
it&rsquo;s just not <i>real time</i>.
Every command from the user is a &lsquo;turn&rsquo; in the game.
During that turn, some &lsquo;game time&rsquo; passes,
which gives other (non-player) characters an equal opportunity to take action.
For example, after the player has taken a swing at an orc,
it&rsquo;s the orc&rsquo;s turn to retaliate.
</p>
<p>
In its simplest form, every command represents an equal time slice.
But it is also possible to make certain commands &lsquo;consume&rsquo; more time than others,
giving the rest of the world more time to do their &lsquo;thing&rsquo; in response.
For example, the player may be given the opportunity
to travel from one town to another with a single &lsquo;go&rsquo; command,
but that may cost the player so much game time,
that night will fall halfway through,
bringing out nasty night crawlers.
&lsquo;Long&rsquo; commands may also consume more resources, like
food, water, physical strength, or fuel for any vehicle you may be driving.
</p>
<p>
At the very least, I would recommend to let &lsquo;supportive&rsquo; commands,
for example &lsquo;help&rsquo;, &lsquo;save&rsquo;, &lsquo;load&rsquo;, consume zero game time.
These commands are not part of the storyline;
it would be unfair to penalize the player for using them.
The same thing goes for typos and other input that is rejected by the parser;
this is supposed to be an adventure, not a
<a href="https://en.wikipedia.org/wiki/Spelling_bee">spelling bee</a>.
</p>
<table><tr>
<td class="snippet">The orc looks very angry.

--&gt; hit orc
You hit the orc on the head.
The orc is dazed, and for a moment, is defenseless.

--&gt; stabbb orc
I don't know how to 'stabbb'.
The orc recovers and strikes back.
You are dead.

--&gt; <span class="red">*** rage quit ***</span>
</td>
</tr></table>
<p>
Please note that in battle, a return action
is not necessarily implied by the player&rsquo;s last command.
Once enraged, the orc is likely to keep responding with violence,
regardless of what the player&rsquo;s subsequent commands will be.
</p>
<table><tr>
<td class="snippet">--&gt; hit orc
You hit the orc; orc loses 10 HP.
Orc strikes back; you lose 10 HP.

--&gt; give flowers to orc
Orc accepts your gift and makes a flower basket out of it.

--&gt; <span class="red">mood swings???</span>
</td>
</tr></table>
<p>
Therefore, it is best to implement all actions from &lsquo;the rest of the world&rsquo;
not as part of any user command, but as a separate step in the main loop.
Remember the main loop from chapter 2?
We will just add a new function call there.
</p>
<table class="code"><tr>
<th>main.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;string.h&gt;</li>
<li class="old">#include "expand.h"</li>
<li class="old">#include "parsexec.h"</li>
<li class="new">#include "turn.h"</li>
<li class="old"></li>
<li class="old">static char input[100] = "look around";</li>
<li class="old"></li>
<li class="old">static bool getFromFP(FILE *fp)</li>
<li class="old">{</li>
<li class="old">   bool ok = fgets(input, sizeof input, fp) != NULL;</li>
<li class="old">   if (ok) input[strcspn(input, "\n")] = '\0';</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool getInput(const char *filename)</li>
<li class="old">{</li>
<li class="old">   static FILE *fp = NULL;</li>
<li class="old">   bool ok;</li>
<li class="old">   if (fp == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (filename != NULL) fp = fopen(filename, "rt");</li>
<li class="old">      if (fp == NULL) fp = stdin;</li>
<li class="old">   }</li>
<li class="old">   else if (fp == stdin &amp;&amp; filename != NULL)</li>
<li class="old">   {</li>
<li class="old">      FILE *out = fopen(filename, "at");</li>
<li class="old">      if (out != NULL)</li>
<li class="old">      {</li>
<li class="old">         fprintf(out, "%s\n", input);</li>
<li class="old">         fclose(out);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   printf("\n--&gt; ");</li>
<li class="old">   ok = getFromFP(fp);</li>
<li class="old">   if (fp != stdin)</li>
<li class="old">   {</li>
<li class="old">      if (ok)</li>
<li class="old">      {</li>
<li class="old">         printf("%s\n", input);</li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         fclose(fp);</li>
<li class="old">         ok = getFromFP(fp = stdin);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">int main(int argc, char *argv[])</li>
<li class="old">{</li>
<li class="old">   (void)argc;</li>
<li class="old">   printf("Welcome to Little Cave Adventure.\n");</li>
<li class="new"><span class="old">   while </span>(turn(parseAndExecute(expand(input,<span class="old"> sizeof </span>input)))<span class="old"> &amp;&amp;</span></li>
<li class="old">          getInput(argv[1]));</li>
<li class="old">   printf("\nBye!\n");</li>
<li class="old">   return 0;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 6:
another new module, shown below.
</li>
<li>Line 56:
directly after calling function parseAndExecute,
we will call a new function named &lsquo;turn&rsquo;.
The return value of parseAndExecute is passed into turn as a parameter.
</li>
</ul>
</div>
<p>
TODO.
</p>
<hr />
<table class="download"><tr><td>
<a class="button" href="code20/src.zip">&#x2B73; &nbsp; Download source code</a>
<a class="button" href="https://repl.it/github/helderman/htpataic">&#x1F300; &nbsp; Run on Repl.it</a>
</td></tr></table>
<p>
Next chapter: <a href="htpataic21.html">21. Database</a>
</p>
</body>
</html>
