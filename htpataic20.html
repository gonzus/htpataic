<!DOCTYPE html>
<html>
<head>
<title>20. Combat</title>
<link rel="stylesheet" href="htpataic.css" type="text/css" />
</head>
<body>
<table class="contents"><tr><td>
<h4>Contents</h4>
<div><a href="htpataic01.html">1. Introduction</a></div>
<div><a href="htpataic02.html">2. The main loop</a></div>
<div><a href="htpataic03.html">3. Locations</a></div>
<div><a href="htpataic04.html">4. Objects</a></div>
<div><a href="htpataic05.html">5. Inventory</a></div>
<div><a href="htpataic06.html">6. Passages</a></div>
<div><a href="htpataic07.html">7. Distance</a></div>
<div><a href="htpataic08.html">8. North, east, south, west</a></div>
<div><a href="htpataic09.html">9. Code generation</a></div>
<div><a href="htpataic10.html">10. More attributes</a></div>
<div><a href="htpataic11.html">11. Conditions</a></div>
<div><a href="htpataic12.html">12. Open and close</a></div>
<div><a href="htpataic13.html">13. The parser</a></div>
<div><a href="htpataic14.html">14. Multiple nouns</a></div>
<div><a href="htpataic15.html">15. Light and dark</a></div>
<div><a href="htpataic16.html">16. Savegame</a></div>
<div><a href="htpataic17.html">17. Test automation</a></div>
<div><a href="htpataic18.html">18. Abbreviations</a></div>
<div><a href="htpataic19.html">19. Conversations</a></div>
<div><b>20. Combat</b></div>
<div><a href="htpataic21.html">21. Database</a></div>
<div><a href="htpataic22.html">22. Speech</a></div>
<div><a href="htpataic23.html">23. JavaScript</a></div>
</td></tr></table>

<h1>How to program a text adventure in C</h1>
<p>
by Ruud Helderman
&lt;<a href="mailto:r.helderman@hccnet.nl">r.helderman@hccnet.nl</a>&gt;
</p>
<p>
Licensed under
<a href="https://github.com/helderman/htpataic/blob/master/LICENSE">MIT License</a>
</p>
<h2>20. Combat</h2>
<p class="intro">
Since the early classics were influenced by
<a href="https://en.wikipedia.org/wiki/Fantasy">fantasy</a>,
it is not surprising that many text-based games adopted elements from
<a href="https://en.wikipedia.org/wiki/Role-playing_game">RPG games</a>
like
<a href="https://en.wikipedia.org/wiki/Dungeons_%26_Dragons">Dungeons &amp; Dragons</a>.
</p>
<p>
Multi-player games thrive on role play and combat; you see that in every
<a href="https://en.wikipedia.org/wiki/MUD">MUD</a>.
Single-player games on the other hand, typically focus on puzzle solving.
The boundaries are not always that sharp.
In the early days, before the rise of
<a href="https://en.wikipedia.org/wiki/Internet">the internet</a>,
there were plenty of single-player games that featured combat,
though often in a simplified form.
</p>
<p>
It is easy enough to implement a &lsquo;kill&rsquo; command that will dispose of any actors standing in your way.
</p>
<table><tr>
<td class="snippet">guard-&gt;health--;    /* do this often enough and he's dead */
</td>
</tr></table>
<p>
But of course there is a lot more to it.
Some weapons may be more effective than others.
Some opponents may be tougher than others.
Both the player and non-player characters stand a better chance in combat
when being healthy, skilled and well-equiped.
A lot can be learned from
<a href="https://en.wikipedia.org/wiki/Tabletop_role-playing_game">tabletop role-playing games</a>,
where
<a href="https://en.wikipedia.org/wiki/Statistic_(role-playing_games)">statistics</a>
determine the chances of survival.
Each stat can be implemented as an attribute in our &lsquo;object&rsquo; structure;
this was discussed in chapter 10.
A combat-related command should use these stats
in a &lsquo;damage formula&rsquo;
that determines the impact of the command on the actors involved.
</p>
<table><tr>
<td class="snippet">guard-&gt;health -= calculate_damage(player, guard);
</td>
</tr></table>
<h3>Random</h3>
<p>
Traditionally, some uncertainty is built into a damage formula.
Tabletop games have
<a href="https://en.wikipedia.org/wiki/Dice">dice</a>,
computer games have a
<a href="https://en.wikipedia.org/wiki/Random_number_generation">random number generator</a>.
Please note that &lsquo;randomness&rsquo; may cause trouble with the
&lsquo;roll-forward&rsquo; savegame technique proposed in chapter 16.
Roll-forward demands repeatability.
When saving a game, you expect the exact same game state when restoring.
But different random numbers might completely change
the outcome of battles that took place prior to saving.
</p>
<p>
Fortunately, computers typically use
<a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudorandom number generators</a>.
Reproducibility is one of their big advantages.
Just make sure to seed the PRNG with the same fixed number at the start of every game.
If you prefer to have a uniquely random game experience for every new game session
(though I doubt that will be relevant for a text adventure,
where a player is typically dedicated to a single ongoing session),
then at least make sure the seed is stored as part of the savegame.
</p>
<p>
This applies not only to combat, but to everything that is random,
for example objects positioned randomly on the map,
or NPCs moving randomly between locations.
</p>
<h3>Real-time vs turn based</h3>
<p>
When implementing combat in a text adventure,
you will have to choose between
<a href="https://en.wikipedia.org/wiki/Turns,_rounds_and_time-keeping_systems_in_games#Real-time">real-time</a>
and
<a href="https://en.wikipedia.org/wiki/Turns,_rounds_and_time-keeping_systems_in_games#Turn-based">turn-based</a>.
In multi-player games, turn-based only makes sense when playing offline (as in
<a href="https://en.wikipedia.org/wiki/Play-by-mail_game">play-by-mail</a>).
Online players do not want to be kept waiting for other players to respond,
which is why a
<a href="https://en.wikipedia.org/wiki/MUD">MUD</a>
is typically played in real time.
This brings a few coding challenges; in particular
<a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronization</a>.
It&rsquo;s also important to implement some kind of
<a href="https://en.wikipedia.org/wiki/Glossary_of_video_game_terms#cooldown">cooldown</a>,
to prevent things like combat to turn into a
<a href="https://en.wikipedia.org/wiki/Speed_typing_contest">speed typing contest</a>.
</p>
<p>
Single-player games are typically turn-based.
Computers respond faster than humans,
so a human player will not be frustrated by the time it takes
for a non-player character to respond to the player&rsquo;s actions.
Turn-based has the advantage of not rushing players,
giving them all the time in the world to think about their next move,
while at the same time offering instant feedback
at every attempt from the player to progress through the game.
</p>
<p>
Turn-based does not mean there is no notion of time;
it&rsquo;s just not <i>real time</i>.
Every command from the user is a &lsquo;turn&rsquo; in the game.
During that turn, some &lsquo;game time&rsquo; passes,
which gives other (non-player) characters an equal opportunity to take action.
For example, after the player has taken a swing at an orc,
it&rsquo;s the orc&rsquo;s turn to retaliate.
</p>
<p>
In its simplest form, every command represents an equal time slice.
But it is also possible to make certain commands &lsquo;consume&rsquo; more time than others,
giving the rest of the world more time to do their &lsquo;thing&rsquo; in response.
For example, the player may be given the opportunity
to travel from one town to another with a single &lsquo;go&rsquo; command,
but that may cost the player so much game time,
that night will fall halfway through,
bringing out nasty night crawlers.
&lsquo;Long&rsquo; commands may also consume more resources, like
food, water, physical strength, and fuel for a lamp.
</p>
<p>
At the very least, I would recommend to let &lsquo;supportive&rsquo; commands,
for example &lsquo;help&rsquo;, &lsquo;save&rsquo;, &lsquo;load&rsquo;, consume zero game time.
These commands are not part of the storyline;
it would be unfair to penalize the player for using them.
The same thing goes for typos and other input that is rejected by the parser;
this is supposed to be an adventure, not a
<a href="https://en.wikipedia.org/wiki/Spelling_bee">spelling bee</a>.
</p>
<table><tr>
<td class="snippet">The orc looks very angry.

--&gt; hit orc
You hit the orc on the head.
The orc is dazed, and for a moment, is defenseless.

--&gt; stabbb orc
I don't know how to 'stabbb'.
The orc recovers and strikes back.
You are dead.

--&gt; <span class="red">*** rage quit ***</span>
</td>
</tr></table>
<p>
Please note that in battle, a return action
is not necessarily implied by the player&rsquo;s last command.
Once enraged, the orc is likely to keep responding with violence,
regardless of what the player&rsquo;s subsequent commands will be.
</p>
<table><tr>
<td class="snippet">--&gt; hit orc
You hit the orc; orc loses 10 HP.
Orc strikes back; you lose 10 HP.

--&gt; give flowers to orc
Orc accepts your gift and makes a flower basket out of it.

--&gt; <span class="red">mood swings???</span>
</td>
</tr></table>
<p>
Therefore, it is best to implement all actions from &lsquo;the rest of the world&rsquo;
not as part of any user command, but as a separate step in the main loop.
Remember the main loop from chapter 2?
We will just make an additional function call there.
</p>
<table class="demo">
<tr><th>Sample output</th></tr>
<tr><td>
Welcome to Little Cave Adventure.<br />
You are in an open field.<br />
You see:<br />
a silver coin<br />
a burly guard<br />
a cave entrance to the east<br />
dense forest all around<br />
a lamp<br />
a wooden club<br />
a dagger<br />
<br />
--&gt; get club<br />
You pick up a wooden club.<br />
<br />
--&gt; get dagger<br />
You pick up a dagger.<br />
<br />
--&gt; get lamp<br />
You pick up a lamp.<br />
<br />
--&gt; attack<br />
You hit a burly guard with a dagger.<br />
You are hit by a burly guard, with bare hands.<br />
<br />
--&gt; attack with club<br />
You hit a burly guard with a wooden club.<br />
<br />
--&gt; drop dagger<br />
You drop a dagger.<br />
You see a burly guard pick up a dagger.<br />
<br />
--&gt; attack guard<br />
You hit a burly guard with a wooden club.<br />
You are hit by a burly guard, with a dagger.<br />
<br />
--&gt; attack with dagger<br />
You are not holding any dagger.<br />
<br />
--&gt; attack with lamp<br />
You try to hit a burly guard with a lamp, but you miss.<br />
<br />
--&gt; wait<br />
Some time passes...<br />
You are hit by a burly guard, with a dagger.<br />
<br />
--&gt; quit<br />
<br />
Bye!<br />
</td></tr>
</table>
<table class="code"><tr>
<th>main.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include &lt;string.h&gt;</li>
<li class="old">#include "expand.h"</li>
<li class="old">#include "parsexec.h"</li>
<li class="new">#include "turn.h"</li>
<li class="old"></li>
<li class="old">static char input[100] = "look around";</li>
<li class="old"></li>
<li class="old">static bool getFromFP(FILE *fp)</li>
<li class="old">{</li>
<li class="old">   bool ok = fgets(input, sizeof input, fp) != NULL;</li>
<li class="old">   if (ok) input[strcspn(input, "\n")] = '\0';</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool getInput(const char *filename)</li>
<li class="old">{</li>
<li class="old">   static FILE *fp = NULL;</li>
<li class="old">   bool ok;</li>
<li class="old">   if (fp == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (filename != NULL) fp = fopen(filename, "rt");</li>
<li class="old">      if (fp == NULL) fp = stdin;</li>
<li class="old">   }</li>
<li class="old">   else if (fp == stdin &amp;&amp; filename != NULL)</li>
<li class="old">   {</li>
<li class="old">      FILE *out = fopen(filename, "at");</li>
<li class="old">      if (out != NULL)</li>
<li class="old">      {</li>
<li class="old">         fprintf(out, "%s\n", input);</li>
<li class="old">         fclose(out);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   printf("\n--&gt; ");</li>
<li class="old">   ok = getFromFP(fp);</li>
<li class="old">   if (fp != stdin)</li>
<li class="old">   {</li>
<li class="old">      if (ok)</li>
<li class="old">      {</li>
<li class="old">         printf("%s\n", input);</li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         fclose(fp);</li>
<li class="old">         ok = getFromFP(fp = stdin);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">int main(int argc, char *argv[])</li>
<li class="old">{</li>
<li class="old">   (void)argc;</li>
<li class="old">   printf("Welcome to Little Cave Adventure.\n");</li>
<li class="new"><span class="old">   while </span>(turn(parseAndExecute(expand(input,<span class="old"> sizeof </span>input)))<span class="old"> &amp;&amp;</span></li>
<li class="old">          getInput(argv[1]));</li>
<li class="old">   printf("\nBye!\n");</li>
<li class="old">   return 0;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 6:
another new module, shown below.
</li>
<li>Line 56:
directly after calling function parseAndExecute,
we will call a new function named &lsquo;turn&rsquo;.
The return value of parseAndExecute is passed into turn as a parameter.
</li>
</ul>
</div>
<p>
Function &lsquo;turn&rsquo; implements
everything that is going on around the player.
In a multi-player game, this would include activity of other human players.
A single-player game only has non-player characters,
but of course there could be many other processes.
A typical example is a lamp that is slowly dying.
Every turn with the lamp being on, it will consume oil or battery power.
Once everything is consumed, the light will dim.
Other examples are forces of nature: a storm, a flood, a volcanic eruption.
</p>
<table class="code"><tr>
<th>turn.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern bool turn(int time);</li>
</ol>
</td>
</tr><tr>
<th>turn.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "misc.h"</li>
<li class="new">#include "location.h"</li>
<li class="new">#include "damage.h"</li>
<li class="new"></li>
<li class="new">static OBJECT *findBestWeaponAround(OBJECT *actor, OBJECT *weapon)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj;</li>
<li class="new">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">   {</li>
<li class="new">      if (isHolding(actor-&gt;location, obj) &amp;&amp; obj-&gt;impact &lt; weapon-&gt;impact)</li>
<li class="new">      {</li>
<li class="new">         weapon = obj;</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return weapon;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void actorTakingTurn(OBJECT *actor)</li>
<li class="new">{</li>
<li class="new">   if (isHolding(player-&gt;location, actor) &amp;&amp; actor-&gt;trust &lt; 0)</li>
<li class="new">   {</li>
<li class="new">      OBJECT *weapon = getOptimalWeapon(actor);</li>
<li class="new">      OBJECT *best = findBestWeaponAround(actor, weapon);</li>
<li class="new">      if (weapon == best)</li>
<li class="new">      {</li>
<li class="new">         dealDamage(actor, weapon, player);</li>
<li class="new">      }</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         best-&gt;location = actor;</li>
<li class="new">         printf("You see %s pick up %s.\n",</li>
<li class="new">                actor-&gt;description, best-&gt;description);</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void depleteLight(OBJECT *obj, int time)</li>
<li class="new">{</li>
<li class="new">   if ((obj-&gt;light -= time) &lt;= 0 &amp;&amp;</li>
<li class="new">       (isHolding(player, obj) || isHolding(player-&gt;location, obj)))</li>
<li class="new">   {</li>
<li class="new">      printf("The light of %s dies out.\n", obj-&gt;description);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool turn(int time)</li>
<li class="new">{</li>
<li class="new">   if (time &gt; 0)</li>
<li class="new">   {</li>
<li class="new">      bool originallyLit = isLit(player-&gt;location);</li>
<li class="new">      OBJECT *obj, *originalLocation = player-&gt;location;</li>
<li class="new">      for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">      {</li>
<li class="new">         if (validObject(obj) &amp;&amp; obj-&gt;location != NULL)</li>
<li class="new">         {</li>
<li class="new">            if (obj-&gt;health &gt; 0) actorTakingTurn(obj);</li>
<li class="new">            if (obj-&gt;light &gt; 0) depleteLight(obj, time);</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">      if (player-&gt;health &lt;= 0)</li>
<li class="new">      {</li>
<li class="new">         printf("You have died. You rise up to a more peaceful place...\n");</li>
<li class="new">         player-&gt;location = heaven;</li>
<li class="new">         player-&gt;health = 100;</li>
<li class="new">         for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">         {</li>
<li class="new">            if (obj-&gt;location == player) obj-&gt;location = field;</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">      if (originallyLit != isLit(player-&gt;location) ||</li>
<li class="new">          originalLocation != player-&gt;location)</li>
<li class="new">      {</li>
<li class="new">         executeLookAround();</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return time &gt;= 0;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 8-19:
this function gives non-player characters a little bit of
<a href="https://en.wikipedia.org/wiki/Artificial_intelligence">artificial intelligence</a>.
An NPC will pick up a more powerful weapon, if any, before attacking.
This may not be the best tactic
in situations where a swift attack would be beneficial.
To make the NPC more intelligent, improve the function
by making a more complex decision tree involving more attributes.
</li>
<li>Line 23:
non-player characters will only be aggressive
when their &lsquo;trust&rsquo; towards the player is negative.
This is a new attribute that is introduced below.
</li>
<li>Line 25:
start off taking the most powerful weapon the NPC is carrying.
</li>
<li>Line 26:
try to find an even more powerful weapon in NPC&rsquo;s surroundings.
</li>
<li>Line 27:
if <i>findBestWeaponAround</i> is unable to find a better weapon,
then it will simply return the original weapon
(the one passed in as a parameter).
</li>
<li>Line 29:
the NPC is attacking.
</li>
<li>Line 33:
the NPC picks up the new weapon.
This ends NPC&rsquo;s turn;
NPC will have to wait until the next turn to attack.
</li>
<li>Line 42-46:
each lamp in the game, when lit, will slowly consume its fuel.
Every turn, property <i>light</i> is decreased by an amount
that equals the time passed.
This will happen regardless of where the lamp is.
The player will be notified once all fuel has been consumed,
but this only happens if the lamp is present at player&rsquo;s location.
Of course, it is also possible to give an early warning, for example
&ldquo;the lamp flickers&rdquo; when <i>light</i> drops below 10.
</li>
<li>Line 49, 51, 79:
time, passed in as a parameter, is typically 1 in this game,
meaning a single unit of time has passed.
There are two special values: 0 and -1.
Zero means the player did not take a turn
(for example because no valid command was entered),
so we let the surrounding world skip its turn too.
A negative number (-1) means the user wants to quit the program.
</li>
<li>Line 55-62:
give every object a chance to do its thing.
But <i>only</i> if that object exists,
i.e. its <i>condition</i> function returns true (see chapter 11),
and its location is not NULL (see chapter 12 and 15).
This helps prevent the lamp from burning fuel while it&rsquo;s off.
</li>
<li>Line 63:
when player&rsquo;s health hits zero, player dies.
</li>
<li>Line 65-67:
As explained in chapter 2, I like to give the player another chance.
Health is restored, and the player is moved to a &lsquo;respawn point&rsquo;.
I made a dedicated location for that, named &lsquo;little heaven&rsquo;.
Your quest does not end there;
I gave heaven a portal that will transport the player back to the field.
This portal is just a straightforward &lsquo;passage&rsquo; (see chapter 6).
You can find heaven and portal in <i>object.txt</i>.
</li>
<li>Line 68-71:
Contrary to what the ancient pharaos believed,
you are going to heaven empty-handed.
Here, all your possessions are being moved to the field.
This makes it very easy for the player to reclaim them
after going through the portal.
Of course, we could also move each object back to its original location
(you may want to add an attribute <i>home</i> to <i>OBJECT</i>),
or make it even more challenging by moving them to random locations.
Do be careful with objects that are required to make progress through the game;
moving a key to a location behind the door it unlocks,
could make the quest impossible.
</li>
<li>Line 73-77:
It is possible player&rsquo;s surroundings change
due to circumstances beyond player&rsquo;s control.
For example, player may be transported to a different location (line 66),
or it may suddenly become dark (line 45).
That warrants the game automatically giving an updated look around.
</li>
</ul>
</div>
<p>
Functions <i>dealDamage</i> and <i>getOptimalWeapon</i>
are implemented in the following module.
Separating them from <i>turn.c</i> makes sense,
because we will need the same functionality once again
as we implement an &lsquo;attack&rsquo; command
by the end of this chapter.
</p>
<table class="code"><tr>
<th>damage.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern void dealDamage(OBJECT *attacker, OBJECT *weapon, OBJECT *victim);</li>
<li class="new">extern OBJECT *getOptimalWeapon(OBJECT *attacker);</li>
</ol>
</td>
</tr><tr>
<th>damage.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdlib.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "misc.h"</li>
<li class="new"></li>
<li class="new">static void describeAttack(OBJECT *attacker, OBJECT *victim,</li>
<li class="new">                           const char *weaponDescription)</li>
<li class="new">{</li>
<li class="new">   if (attacker == player)</li>
<li class="new">   {</li>
<li class="new">      printf("You hit %s with %s.\n", victim-&gt;description, weaponDescription);</li>
<li class="new">   }</li>
<li class="new">   else if (victim == player)</li>
<li class="new">   {</li>
<li class="new">      printf("You are hit by %s, with %s.\n",</li>
<li class="new">             attacker-&gt;description, weaponDescription);</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("You see %s being hit by %s, with %s.\n",</li>
<li class="new">             victim-&gt;description, attacker-&gt;description, weaponDescription);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void describeDeath(OBJECT *attacker, OBJECT *victim)</li>
<li class="new">{</li>
<li class="new">   if (attacker == player)</li>
<li class="new">   {</li>
<li class="new">      printf("You have slain %s.\n", victim-&gt;description);</li>
<li class="new">   }</li>
<li class="new">   else if (victim == player)</li>
<li class="new">   {</li>
<li class="new">      printf("You have been slain by %s.\n", attacker-&gt;description);</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("You see %s being slain by %s.\n",</li>
<li class="new">             victim-&gt;description, attacker-&gt;description);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void describeAlreadyDead(OBJECT *victim)</li>
<li class="new">{</li>
<li class="new">   if (victim == player)</li>
<li class="new">   {</li>
<li class="new">      printf("It has little effect, since you were already dead.\n");</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("It has little effect, since %s was already dead.\n",</li>
<li class="new">             victim-&gt;description);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void dealDamage(OBJECT *attacker, OBJECT *weapon, OBJECT *victim)</li>
<li class="new">{</li>
<li class="new">   const char *weaponDescription = weapon == attacker ? "bare hands"</li>
<li class="new">                                                      : weapon-&gt;description;</li>
<li class="new">   int damage = (rand() % 6) * weapon-&gt;impact * attacker-&gt;health / 100;</li>
<li class="new">   if (damage &lt; 0)</li>
<li class="new">   {</li>
<li class="new">      describeAttack(attacker, victim, weaponDescription);</li>
<li class="new">      if (victim-&gt;health &lt;= 0)</li>
<li class="new">      {</li>
<li class="new">         describeAlreadyDead(victim);</li>
<li class="new">      }</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         victim-&gt;health += damage;</li>
<li class="new">         if (victim-&gt;health &lt;= 0)</li>
<li class="new">         {</li>
<li class="new">            victim-&gt;health = 0;</li>
<li class="new">            describeDeath(attacker, victim);</li>
<li class="new">         }</li>
<li class="new">         if (attacker == player)</li>
<li class="new">         {</li>
<li class="new">            victim-&gt;trust--;</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   else if (attacker == player)</li>
<li class="new">   {</li>
<li class="new">      printf("You try to hit %s with %s, but you miss.\n",</li>
<li class="new">             victim-&gt;description, weaponDescription);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">OBJECT *getOptimalWeapon(OBJECT *attacker)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj, *weapon = attacker;</li>
<li class="new">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">   {</li>
<li class="new">      if (isHolding(attacker, obj) &amp;&amp; obj-&gt;impact &lt; weapon-&gt;impact)</li>
<li class="new">      {</li>
<li class="new">         weapon = obj;</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return weapon;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 7-24:
a helper function that generates descriptive text
about attacks taking place during combat.
This covers player attacking NPC (line 12),
NPC attacking player (lines 16-17)
and even NPC attacking NPC (lines 21-22).
The latter could be useful in a game
where the player can team up with friendly NPCs.
</li>
<li>Line 26-41:
another helper function, this time to give descriptive text
about a character dying in combat.
As in the previous function,
attacker and victim can be NPC as well as player.
</li>
<li>Line 43-54:
one more helper function,
which could be useful in a fight involving three or more characters,
where a single character might suffer multiple blows within a single turn.
</li>
<li>Line 60:
this is the &lsquo;damage formula&rsquo;.
By convention, I will let &lsquo;damage&rsquo; be a negative number,
reserving positive numbers for actions
that have a positive effect on a character&rsquo;s health
(e.g. drinking a healing potion).
</li>
<li>Line 61:
damage has a 1 to 6 chance of being zero;
even more so if attacker and weapon are too weak.
If damage is zero, then execution will continue on line 82,
where we will explain the attack had no effect.
</li>
<li>Line 78:
attacking an NPC has a (negative) effect not only on health,
but also on the NPC&rsquo;s trust towards the player.
This will have its effect on the NPC&rsquo;s behavior towards the player.
We already saw an example of this in <i>turn.c</i>.
</li>
<li>Line 82:
we should respond to every command from the player,
but it is not necessary to apologize
for every missed opportunity by a NPC to deal damage.
</li>
<li>Line 94:
you may already have noticed the weapon&rsquo;s &lsquo;impact&rsquo;
(another new attribute) as part of the damage formula (line 60).
As explained, we will be using negative numbers.
This explains why there is a &lsquo;less than&rsquo; operator here:
the best weapon is the one with the smallest (most negative) impact.
</li>
</ul>
</div>
<p>
Now that we have given other characters the means to attack the player,
it&rsquo;s time to let the player return the favor!
</p>
<table class="code"><tr>
<th>parsexec.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;ctype.h&gt;</li>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old">#include "match.h"</li>
<li class="old">#include "location.h"</li>
<li class="old">#include "inventory.h"</li>
<li class="old">#include "inventory2.h"</li>
<li class="old">#include "openclose.h"</li>
<li class="old">#include "onoff.h"</li>
<li class="old">#include "talk.h"</li>
<li class="new">#include "attack.h"</li>
<li class="old"></li>
<li class="old">typedef struct</li>
<li class="old">{</li>
<li class="old">   const char *pattern;</li>
<li class="new"><span class="old">   </span>int<span class="old"> (*function)(void);</span></li>
<li class="old">} COMMAND;</li>
<li class="old"></li>
<li class="new"><span class="old">static </span>int<span class="old"> executeQuit(void)</span></li>
<li class="old">{</li>
<li class="new"><span class="old">   return </span>-1;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="new"><span class="old">static </span>int<span class="old"> executeNoMatch(void)</span></li>
<li class="old">{</li>
<li class="old">   const char *src = *params;</li>
<li class="old">   if (*src != '\0')</li>
<li class="old">   {</li>
<li class="old">      printf("I don't know how to '");</li>
<li class="old">      while (*src != '\0' &amp;&amp; !isspace(*src)) putchar(*src++);</li>
<li class="old">      printf("'.\n");</li>
<li class="old">   }</li>
<li class="new"><span class="old">   return </span>0;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="new">static int executeWait(void)</li>
<li class="new">{</li>
<li class="new">   printf("Some time passes...\n");</li>
<li class="new">   return 1;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">int<span class="old"> parseAndExecute(const char *input)</span></li>
<li class="old">{</li>
<li class="old">   static const COMMAND commands[] =</li>
<li class="old">   {</li>
<li class="old">      { "quit"                , executeQuit       },</li>
<li class="old">      { "look"                , executeLookAround },</li>
<li class="old">      { "look around"         , executeLookAround },</li>
<li class="old">      { "look at A"           , executeLook       },</li>
<li class="old">      { "look A"              , executeLook       },</li>
<li class="old">      { "examine A"           , executeLook       },</li>
<li class="old">      { "go to A"             , executeGo         },</li>
<li class="old">      { "go A"                , executeGo         },</li>
<li class="old">      { "get A from B"        , executeGetFrom    },</li>
<li class="old">      { "get A"               , executeGet        },</li>
<li class="old">      { "put A in B"          , executePutIn      },</li>
<li class="old">      { "drop A in B"         , executePutIn      },</li>
<li class="old">      { "drop A"              , executeDrop       },</li>
<li class="old">      { "ask A from B"        , executeAskFrom    },</li>
<li class="old">      { "ask A"               , executeAsk        },</li>
<li class="old">      { "give A to B"         , executeGiveTo     },</li>
<li class="old">      { "give A"              , executeGive       },</li>
<li class="old">      { "inventory"           , executeInventory  },</li>
<li class="old">      { "open A"              , executeOpen       },</li>
<li class="old">      { "close A"             , executeClose      },</li>
<li class="old">      { "lock A"              , executeLock       },</li>
<li class="old">      { "unlock A"            , executeUnlock     },</li>
<li class="old">      { "turn on A"           , executeTurnOn     },</li>
<li class="old">      { "turn off A"          , executeTurnOff    },</li>
<li class="old">      { "turn A on"           , executeTurnOn     },</li>
<li class="old">      { "turn A off"          , executeTurnOff    },</li>
<li class="old">      { "talk with B about A" , executeTalkTo     },</li>
<li class="old">      { "talk about A with B" , executeTalkTo     },</li>
<li class="old">      { "talk about A"        , executeTalk       },</li>
<li class="new"><span class="old">      { "talk A"              , executeTalk       </span>},</li>
<li class="new">      { "attack with B"       , executeAttack     },</li>
<li class="new">      { "attack A with B"     , executeAttack     },</li>
<li class="new">      { "attack A"            , executeAttack     },</li>
<li class="new">      { "wait"                , executeWait<span class="old">       },</span></li>
<li class="old">      { "A"                   , executeNoMatch    }</li>
<li class="old">   };</li>
<li class="old">   const COMMAND *cmd;</li>
<li class="old">   for (cmd = commands; !matchCommand(input, cmd-&gt;pattern); cmd++);</li>
<li class="old">   return (*cmd-&gt;function)();</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 18, 21, 26, 44:
we are changing the return type of the command functions
from <i>bool</i> to <i>int</i>.
This is a sweeping change through a lot of modules
(<i>inventory.c</i>, <i>inventory2.c</i>, <i>location.c</i>,
<i>move.c</i>, <i>onoff.c</i>, <i>openclose.c</i>, <i>talk.c</i>).
Unsurprising; for every command, we need to make up ours minds
how many time unit are being consumed by the execution of that command.
</li>
<li>Line 23:
every command function should return the number of time units consumed.
<i>Quit</i> is the exception to the rule: it returns -1,
to signal the main loop that the program should end.
</li>
<li>Line 35:
here you see one of the situations where a command function returns zero.
The command has not been recognized, either because the player made a typo,
or because the game&rsquo;s vocabulair is too limited.
Neither is considered part of the story; no game time passes.
</li>
<li>Line 38-42, 81:
with the introduction of &lsquo;time&rsquo;,
there should also be a command that allows the player
to just let time pass without actually doing anything.
This may seem useless, but it can be fun to have a puzzle in the game
that actually relies on the execution of this command.
Patience is a virtue, so why not reward it?
</li>
<li>Line 78-80:
we are introducing a new command &lsquo;attack&rsquo;, with two arguments:
A represents the victim, B the weapon.
Both are optional; below we will see how this is handled.
Of course, you can register as many synonyms as you like:
<i>hit</i>, <i>kill</i>, <i>stab</i>, <i>slay</i>...
</li>
</ul>
</div>
<p>
It is time to implement the command &lsquo;attack&rsquo;.
</p>
<table class="code"><tr>
<th>attack.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern int executeAttack(void);</li>
</ol>
</td>
</tr><tr>
<th>attack.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "misc.h"</li>
<li class="new">#include "match.h"</li>
<li class="new">#include "noun.h"</li>
<li class="new">#include "reach.h"</li>
<li class="new">#include "damage.h"</li>
<li class="new"></li>
<li class="new">static OBJECT *victimHere()</li>
<li class="new">{</li>
<li class="new">   OBJECT *victim = actorHere();</li>
<li class="new">   if (victim == NULL)</li>
<li class="new">   {</li>
<li class="new">      printf("There is nobody here to attack.\n");</li>
<li class="new">   }</li>
<li class="new">   return victim;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">int executeAttack(void)</li>
<li class="new">{</li>
<li class="new">   OBJECT *victim =</li>
<li class="new">      *params[0] == '\0' ? victimHere()</li>
<li class="new">                         : reachableObject("who to attack", params[0]);</li>
<li class="new">   if (victim != NULL)</li>
<li class="new">   {</li>
<li class="new">      OBJECT *weapon =</li>
<li class="new">         *params[1] == '\0' ? getOptimalWeapon(player)</li>
<li class="new">                            : getPossession(player, "wield", params[1]);</li>
<li class="new">      if (weapon != NULL)</li>
<li class="new">      {</li>
<li class="new">         dealDamage(player, weapon, victim);</li>
<li class="new">         return 1;</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return 0;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Lines 10-18, 23:
a little helper function in case the command is given without a victim.
It extends upon function <i>actorHere</i>, which is used
in a similar way for commands <i>ask</i>, <i>give</i> and <i>talk</i>.
</li>
<li>Line 28:
the command can also be given without explicitly specifying a weapon.
In that case, the best weapon at hand will be used.
For this, we use the same function <i>getOptimalWeapon</i> that was
used in <i>turn.c</i> to let non-player characters choose their weapon.
</li>
<li>Line 32:
<i>dealDamage</i> is another function that we were already using
in <i>turn.c</i> to let non-player character make their move.
This time, the player is the attacker rather than the victim.
</li>
</ul>
</div>
<p>
Finally, here are the new attributes,
the weapons and the respawn location.
</p>
<table class="code"><tr>
<th>object.txt</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "toggle.h"</li>
<li class="old"></li>
<li class="old">typedef struct object {</li>
<li class="old">   bool         (*condition)(void);</li>
<li class="old">   const char    *description;</li>
<li class="old">   const char   **tags;</li>
<li class="old">   struct object *location;</li>
<li class="old">   struct object *destination;</li>
<li class="old">   struct object *prospect;</li>
<li class="old">   const char    *details;</li>
<li class="old">   const char    *contents;</li>
<li class="old">   const char    *textGo;</li>
<li class="old">   const char    *gossip;</li>
<li class="old">   int            weight;</li>
<li class="old">   int            capacity;</li>
<li class="old">   int            health;</li>
<li class="old">   int            light;</li>
<li class="new">   int            impact;</li>
<li class="new">   int            trust;</li>
<li class="old">   const char  *(*open)(void);</li>
<li class="old">   const char  *(*close)(void);</li>
<li class="old">   const char  *(*lock)(void);</li>
<li class="old">   const char  *(*unlock)(void);</li>
<li class="old">} OBJECT;</li>
<li class="old"></li>
<li class="old">extern OBJECT objs[];</li>
<li class="old"></li>
<li class="old">- gossipEWNS</li>
<li class="old">     tags        "east", "west", "north", "south"</li>
<li class="old">     gossip      "It's just a compass direction."</li>
<li class="old"></li>
<li class="old">- field</li>
<li class="old">     description "an open field"</li>
<li class="old">     tags        "field"</li>
<li class="old">     details     "The field is a nice and quiet place under a clear blue sky.\n"</li>
<li class="old">     gossip      "A lot of tourists go there."</li>
<li class="old">     capacity    9999</li>
<li class="old">     light       100</li>
<li class="old"></li>
<li class="old">- cave</li>
<li class="old">     description "a little cave"</li>
<li class="old">     tags        "cave"</li>
<li class="old">     details     "The cave is just a cold, damp, rocky chamber.\n"</li>
<li class="old">     gossip      "It's dark in there; bring a lamp!"</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- silver</li>
<li class="old">     description "a silver coin"</li>
<li class="old">     tags        "silver", "coin", "silver coin"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The coin has an eagle on the obverse.\n"</li>
<li class="old">     gossip      "Money makes the world go round..."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- gold</li>
<li class="old">     description "a gold coin"</li>
<li class="old">     tags        "gold", "coin", "gold coin"</li>
<li class="old">     location    openBox</li>
<li class="old">     details     "The shiny coin seems to be a rare and priceless artefact.\n"</li>
<li class="old">     gossip      "Money makes the world go round..."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- guard</li>
<li class="old">     description "a burly guard"</li>
<li class="old">     tags        "guard", "burly guard"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The guard is a really big fellow.\n"</li>
<li class="old">     gossip      "Easy to bribe..."</li>
<li class="old">     contents    "He has"</li>
<li class="old">     health      100</li>
<li class="new">     impact      -1</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- player</li>
<li class="old">     description "yourself"</li>
<li class="old">     tags        "yourself"</li>
<li class="old">     location    field</li>
<li class="old">     details     "You would need a mirror to look at yourself.\n"</li>
<li class="old">     gossip      "You're not from around here, are you?"</li>
<li class="old">     contents    "You have"</li>
<li class="old">     health      100</li>
<li class="new">     impact      -1</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- intoCave</li>
<li class="old">     condition   { return guard-&gt;health == 0 || silver-&gt;location == guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop.\n"</li>
<li class="old">     textGo      "You walk into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- intoCaveBlocked</li>
<li class="old">     condition   { return guard-&gt;health &gt; 0 &amp;&amp; silver-&gt;location != guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop.\n"</li>
<li class="old">     textGo      "The guard stops you from walking into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- exitCave</li>
<li class="old">     description "an exit to the west"</li>
<li class="old">     tags        "west", "exit"</li>
<li class="old">     location    cave</li>
<li class="old">     destination field</li>
<li class="old">     details     "Sunlight pours in through an opening in the cave's wall.\n"</li>
<li class="old">     textGo      "You walk out of the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- wallField</li>
<li class="old">     description "dense forest all around"</li>
<li class="old">     tags        "west", "north", "south", "forest"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The field is surrounded by trees and undergrowth.\n"</li>
<li class="old">     textGo      "Dense forest is blocking the way.\n"</li>
<li class="old">     gossip      "You cannot go there, it is impenetrable."</li>
<li class="old"></li>
<li class="old">- wallCave</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "north", "rock"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "Carved in stone is a secret password 'abccb'.\n"</li>
<li class="old">     textGo      "Solid rock is blocking the way.\n"</li>
<li class="old"></li>
<li class="old">- backroom</li>
<li class="old">     description "a backroom"</li>
<li class="old">     tags        "backroom"</li>
<li class="old">     details     "The room is dusty and messy.\n"</li>
<li class="old">     gossip      "There is something of value to be found there."</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- wallBackroom</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "west", "south", "rock"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "Trendy wallpaper covers the rock walls.\n"</li>
<li class="old">     textGo      "Solid rock is blocking the way.\n"</li>
<li class="old"></li>
<li class="old">- openDoorToBackroom</li>
<li class="old">     description "an open door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     destination backroom</li>
<li class="old">     details     "The door is open.\n"</li>
<li class="old">     textGo      "You walk through the door into a backroom.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleBackdoor</li>
<li class="old"></li>
<li class="old">- closedDoorToBackroom</li>
<li class="old">     description "a closed door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     location    cave</li>
<li class="old">     prospect    backroom</li>
<li class="old">     details     "The door is closed.\n"</li>
<li class="old">     textGo      "The door is closed.\n"</li>
<li class="old">     open        toggleBackdoor</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openDoorToCave</li>
<li class="old">     description "an open door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The door is open.\n"</li>
<li class="old">     textGo      "You walk through the door into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleBackdoor</li>
<li class="old"></li>
<li class="old">- closedDoorToCave</li>
<li class="old">     description "a closed door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     location    backroom</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The door is closed.\n"</li>
<li class="old">     textGo      "The door is closed.\n"</li>
<li class="old">     open        toggleBackdoor</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is open.\n"</li>
<li class="old">     gossip      "You need a key to open it."</li>
<li class="old">     weight      5</li>
<li class="old">     capacity    10</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleBox</li>
<li class="old">     lock        isStillOpen</li>
<li class="old">     unlock      isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- closedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is closed.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     open        toggleBox</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        toggleBoxLock</li>
<li class="old">     unlock      isAlreadyUnlocked</li>
<li class="old"></li>
<li class="old">- lockedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "The box is closed.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     open        isStillLocked</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        isAlreadyLocked</li>
<li class="old">     unlock      toggleBoxLock</li>
<li class="old"></li>
<li class="old">- keyForBox</li>
<li class="old">     description "a tiny key"</li>
<li class="old">     tags        "key", "tiny key"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "The key is really small and shiny.\n"</li>
<li class="old">     gossip      "A small key opens a small lock."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- lampOff</li>
<li class="old">     description "a lamp"</li>
<li class="old">     tags        "lamp"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The lamp is off.\n"</li>
<li class="old">     gossip      "Essential in dark areas."</li>
<li class="old">     weight      5</li>
<li class="old"></li>
<li class="old">- lampOn</li>
<li class="old">     description "a lamp"</li>
<li class="old">     tags        "lamp"</li>
<li class="old">     details     "The lamp is on.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     light       100</li>
<li class="new"></li>
<li class="new">- club</li>
<li class="new">     description "a wooden club"</li>
<li class="new">     tags        "club", "wooden club"</li>
<li class="new">     location    field</li>
<li class="new">     details     "Two feet of solid wood.\n"</li>
<li class="new">     weight      5</li>
<li class="new">     impact      -2</li>
<li class="new"></li>
<li class="new">- dagger</li>
<li class="new">     description "a dagger"</li>
<li class="new">     tags        "dagger"</li>
<li class="new">     location    field</li>
<li class="new">     details     "The dagger is very sharp.\n"</li>
<li class="new">     weight      7</li>
<li class="new">     impact      -5</li>
<li class="new"></li>
<li class="new">- heaven</li>
<li class="new">     description "little heaven"</li>
<li class="new">     tags        "heaven", "little heaven"</li>
<li class="new">     details     "Everything looks so peaceful here.\n"</li>
<li class="new">     gossip      "It's where all the good adventurers go."</li>
<li class="new">     capacity    9999</li>
<li class="new">     light       100</li>
<li class="new"></li>
<li class="new">- respawn</li>
<li class="new">     description "a respawn portal"</li>
<li class="new">     tags        "portal", "respawn portal"</li>
<li class="new">     location    heaven</li>
<li class="new">     destination field</li>
<li class="new">     details     "Looks like a gateway into the unknown.\n"</li>
<li class="new">     textGo      "A bright flash of light, and you are back in the field.\n"</li>
<li class="new">     open        isAlreadyOpen</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 21-22:
the new attributes &lsquo;impact&rsquo; and &lsquo;trust&rsquo;.
</li>
<li>Lines 74, 85:
most actors can fight without a weapon.
It basically means the actor <i>is</i> the weapon.
Here we specify the effect of each actor fighting with bare hands.
</li>
<li>Line 240-254:
a number of weapons.
</li>
<li>Line 256-271:
&lsquo;little heaven&rsquo; and its portal leading back to earth.
</li>
</ul>
</div>
<p>
The new attributes demand a change in <i>object.awk</i> as well.
</p>
<img class="genmap" src="code20/map.png" />
<table class="code"><tr>
<th>object.awk</th>
</tr><tr>
<td>
<ol>
<li class="old">BEGIN {</li>
<li class="old">   count = 0;</li>
<li class="old">   obj = "";</li>
<li class="old">   if (pass == "c2") {</li>
<li class="old">      print "\nstatic bool alwaysTrue(void) { return true; }";</li>
<li class="old">      print "\nOBJECT objs[] = {";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">/^- / {</li>
<li class="old">   outputRecord(",");</li>
<li class="old">   obj = $2;</li>
<li class="old">   prop["condition"]   = "alwaysTrue";</li>
<li class="old">   prop["description"] = "NULL";</li>
<li class="old">   prop["tags"]        = "";</li>
<li class="old">   prop["location"]    = "NULL";</li>
<li class="old">   prop["destination"] = "NULL";</li>
<li class="old">   prop["prospect"]    = "";</li>
<li class="old">   prop["details"]     = "\"You see nothing special.\\n\"";</li>
<li class="old">   prop["contents"]    = "\"You see\"";</li>
<li class="old">   prop["textGo"]      = "\"You can't get much closer than this.\\n\"";</li>
<li class="old">   prop["gossip"]      = "\"I know nothing about that.\"";</li>
<li class="old">   prop["weight"]      = "99";</li>
<li class="old">   prop["capacity"]    = "0";</li>
<li class="old">   prop["health"]      = "0";</li>
<li class="old">   prop["light"]       = "0";</li>
<li class="new">   prop["impact"]      = "0";</li>
<li class="new">   prop["trust"]       = "0";</li>
<li class="old">   prop["open"]        = "cannotBeOpened";</li>
<li class="old">   prop["close"]       = "cannotBeClosed";</li>
<li class="old">   prop["lock"]        = "cannotBeLocked";</li>
<li class="old">   prop["unlock"]      = "cannotBeUnlocked";</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">obj &amp;&amp; /^[ \t]+[a-z]/ {</li>
<li class="old">   name = $1;</li>
<li class="old">   $1 = "";</li>
<li class="old">   if (name in prop) {</li>
<li class="old">      prop[name] = $0;</li>
<li class="old">      if (/^[ \t]*\{/) {</li>
<li class="old">         prop[name] = name count;</li>
<li class="old">         if (pass == "c1") print "static bool " prop[name] "(void) " $0;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (pass == "c2") {</li>
<li class="old">      print "#error \"" FILENAME " line " NR ": unknown attribute '" name "'\"";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">!obj &amp;&amp; pass == (/^#include/ ? "c1" : "h") {</li>
<li class="old">   print;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">END {</li>
<li class="old">   outputRecord("\n};");</li>
<li class="old">   if (pass == "h") {</li>
<li class="old">      print "\n#define endOfObjs\t(objs + " count ")";</li>
<li class="old">      print "\n#define validObject(obj)\t" \</li>
<li class="old">            "((obj) != NULL &amp;&amp; (*(obj)-&gt;condition)())";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">function outputRecord(separator)</li>
<li class="old">{</li>
<li class="old">   if (obj) {</li>
<li class="old">      if (pass == "h") {</li>
<li class="old">         print "#define " obj "\t(objs + " count ")";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c1") {</li>
<li class="old">         print "static const char *tags" count "[] = {" prop["tags"] ", NULL};";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c2") {</li>
<li class="old">         print "\t{\t/* " count " = " obj " */";</li>
<li class="old">         print "\t\t" prop["condition"] ",";</li>
<li class="old">         print "\t\t" prop["description"] ",";</li>
<li class="old">         print "\t\ttags" count ",";</li>
<li class="old">         print "\t\t" prop["location"] ",";</li>
<li class="old">         print "\t\t" prop["destination"] ",";</li>
<li class="old">         print "\t\t" prop[prop["prospect"] ? "prospect" : "destination"] ",";</li>
<li class="old">         print "\t\t" prop["details"] ",";</li>
<li class="old">         print "\t\t" prop["contents"] ",";</li>
<li class="old">         print "\t\t" prop["textGo"] ",";</li>
<li class="old">         print "\t\t" prop["gossip"] ",";</li>
<li class="old">         print "\t\t" prop["weight"] ",";</li>
<li class="old">         print "\t\t" prop["capacity"] ",";</li>
<li class="old">         print "\t\t" prop["health"] ",";</li>
<li class="old">         print "\t\t" prop["light"] ",";</li>
<li class="new">         print "\t\t" prop["impact"] ",";</li>
<li class="new">         print "\t\t" prop["trust"] ",";</li>
<li class="old">         print "\t\t" prop["open"] ",";</li>
<li class="old">         print "\t\t" prop["close"] ",";</li>
<li class="old">         print "\t\t" prop["lock"] ",";</li>
<li class="old">         print "\t\t" prop["unlock"];</li>
<li class="old">         print "\t}" separator;</li>
<li class="old">         delete prop;</li>
<li class="old">      }</li>
<li class="old">      count++;</li>
<li class="old">   }</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 27-28:
both attributes have a default value of zero.
</li>
</ul>
</div>
<p>
That&rsquo;s about it as far as game logic goes.
To make it a real game, we need more objects
(locations, actors, items)
and more puzzles.
The latter can be done by
adding custom code to the various modules we have seen so far.
</p>
<p>
I am still working on extra chapters, covering some technical topics.
</p>
<hr />
<table class="download"><tr><td>
<a class="button" href="code20/src.zip">&#x2B73; &nbsp; Download source code</a>
<a class="button" href="https://repl.it/github/helderman/htpataic">&#x1F300; &nbsp; Run on Repl.it</a>
</td></tr></table>
<p>
Next chapter: <a href="htpataic21.html">21. Database</a>
</p>
</body>
</html>
