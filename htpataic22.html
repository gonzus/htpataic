<!DOCTYPE html>
<html>
<head>
<title>22. Client-server</title>
<link rel="stylesheet" href="htpataic.css" type="text/css" />
</head>
<body>
<table class="contents"><tr><td>
<h4>Contents</h4>
<div><a href="htpataic01.html">1. Introduction</a></div>
<div><a href="htpataic02.html">2. The main loop</a></div>
<div><a href="htpataic03.html">3. Locations</a></div>
<div><a href="htpataic04.html">4. Objects</a></div>
<div><a href="htpataic05.html">5. Inventory</a></div>
<div><a href="htpataic06.html">6. Passages</a></div>
<div><a href="htpataic07.html">7. Distance</a></div>
<div><a href="htpataic08.html">8. North, east, south, west</a></div>
<div><a href="htpataic09.html">9. Code generation</a></div>
<div><a href="htpataic10.html">10. More attributes</a></div>
<div><a href="htpataic11.html">11. Conditions</a></div>
<div><a href="htpataic12.html">12. Open and close</a></div>
<div><a href="htpataic13.html">13. The parser</a></div>
<div><a href="htpataic14.html">14. Multiple nouns</a></div>
<div><a href="htpataic15.html">15. Light and dark</a></div>
<div><a href="htpataic16.html">16. Savegame</a></div>
<div><a href="htpataic17.html">17. Test automation</a></div>
<div><a href="htpataic18.html">18. Abbreviations</a></div>
<div><a href="htpataic19.html">19. Conversations</a></div>
<div><a href="htpataic20.html">20. Combat</a></div>
<div><a href="htpataic21.html">21. Multi-player</a></div>
<div><b>22. Client-server</b></div>
<div><a href="htpataic23.html">23. Database</a></div>
<div><a href="htpataic24.html">24. Speech</a></div>
<div><a href="htpataic25.html">25. JavaScript</a></div>
</td></tr></table>

<h1>How to program a text adventure in C</h1>
<p>
by Ruud Helderman
&lt;<a href="mailto:r.helderman@hccnet.nl">r.helderman@hccnet.nl</a>&gt;
</p>
<p>
Licensed under
<a href="https://github.com/helderman/htpataic/blob/master/LICENSE">MIT License</a>
</p>
<h2>22. Client-server</h2>
<p class="intro">
It would be perfectly retro
to have a single person type in every command for every player.
What we made in the previous chapter, might already be enough to run your own
<a href="https://en.wikipedia.org/wiki/Play-by-mail_game">play-by-mail game</a>.
But in the 21st century,
&lsquo;multi-player&rsquo; has become synonymous with
<a href="https://en.wikipedia.org/wiki/Online_game">online gaming</a>.
So let&rsquo;s see if we can make that happen!
</p>
<p>
To make our game multi-user, we will turn it into a
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>
server.
Each user will connect to the server with a standard
<a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a>
client.
Sounds old-school? It is.
But it&rsquo;s probably closest to how the early MUDs were made.
And it&rsquo;s fun to write your own server almost from scratch.
</p>
<p>
So basically,
our program <i>lilcave</i> should be running continuously on a computer.
The computer should always be online; it should never be turned off.
In the early days of the internet,
that typically meant the program would be running on a university
<a href="https://en.wikipedia.org/wiki/Minicomputer">mini</a>
or
<a href="https://en.wikipedia.org/wiki/Mainframe_computer">mainframe</a>,
under the supervision of the super user
(or more likely, covertly scheduled by a smart student).
</p>
<p>
With today&rsquo;s hardware, any
<a href="https://en.wikipedia.org/wiki/Personal_computer">PC</a>
will do fine running such a game.
But since it is an online game, there are a few things to keep in mind.
</p>
<ul>
<li>Assuming your machine has a
<a href="https://en.wikipedia.org/wiki/Firewall_(computing)">firewall</a>,
you will need to add a rule allowing <i>inbound</i> traffic to your program,
protocol TCP, port 18811
(or whatever number is being specified in <i>server.c</i>; see below).
With the built-in firewall of
<a href="https://en.wikipedia.org/wiki/Microsoft_Windows">MS Windows</a>,
that&rsquo;s easy enough: the firewall will automatically
propose the necessary adjustment as soon as you first launch your program.
</li>
<li>Assuming your home network is separated from the internet by a
<a href="https://en.wikipedia.org/wiki/Router_(computing)">router</a>,
you will need to configure
<a href="https://en.wikipedia.org/wiki/Port_forwarding">port forwarding</a>
on the router.
</li>
<li>You may want to keep the game running day and night.
That warrants an energy-efficient machine, for example a
<a href="https://en.wikipedia.org/wiki/Raspberry_Pi">Raspberry Pi</a>.
</li>
<li>Rather than running your own
<a href="https://en.wikipedia.org/wiki/Home_server">home server</a>,
you might consider having your game
<a href="https://en.wikipedia.org/wiki/Internet_hosting_service">hosted</a>
by a third party at a monthly fee.
A
<a href="https://en.wikipedia.org/wiki/Text-based_game">text-based</a>
game typically has small demands, so you could probably settle
for a minimal amount of memory, disk space and bandwidth.
But do make sure the package comes with a C compiler,
as you will need to build your game from source on the hosted server.
</li>
</ul>
<p>
Implementing a TCP server in C is pretty straightforward.
It involves writing quite a bit of
<a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a>
around
<a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>,
the <i>de facto</i> standard for a
<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client-server</a>
application.
Fortunately, code samples can be found anywhere on the internet.
</p>
<table class="code"><tr>
<th>server.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern void server(bool (*action)(char *, int));</li>
</ol>
</td>
</tr><tr>
<th>server.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include &lt;unistd.h&gt;</li>
<li class="new">#include &lt;netinet/in.h&gt;</li>
<li class="new">#include "break.h"</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "print.h"</li>
<li class="new">#include "outbuf.h"</li>
<li class="new">#include "telnet.h"</li>
<li class="new">#include "client.h"</li>
<li class="new">#include "tcp.h"</li>
<li class="new"></li>
<li class="new">#define PORT  18811</li>
<li class="new"></li>
<li class="new">static void disconnect(CLIENT *client)</li>
<li class="new">{</li>
<li class="new">   if (client-&gt;fd != -1)</li>
<li class="new">   {</li>
<li class="new">      close(client-&gt;fd);</li>
<li class="new">      printConsole("Socket %d disconnected.\n", client-&gt;fd);</li>
<li class="new">      client-&gt;fd = -1;</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void server(bool (*action)(char *, int))</li>
<li class="new">{</li>
<li class="new">   struct sockaddr_in address;</li>
<li class="new">   int listener = tcpListen(&amp;address, PORT);</li>
<li class="new">   int i;</li>
<li class="new">   CLIENT *client;</li>
<li class="new">   clientInit();</li>
<li class="new"></li>
<li class="new">   for (breakInit(); breakTest(); )</li>
<li class="new">   {</li>
<li class="new">      fd_set fds;</li>
<li class="new">      int fd = listener;</li>
<li class="new">      FD_ZERO(&amp;fds);</li>
<li class="new">      FD_SET(listener, &amp;fds);</li>
<li class="new">      for (i = 0; (client = clientGet(i)) != NULL; i++)</li>
<li class="new">      {</li>
<li class="new">         if (client-&gt;fd != -1) FD_SET(client-&gt;fd, &amp;fds);</li>
<li class="new">         if (client-&gt;fd &gt; fd) fd = client-&gt;fd;</li>
<li class="new">      }</li>
<li class="new">      if (tcpSelect(fd + 1, &amp;fds) == -1) break;</li>
<li class="new"></li>
<li class="new">      if (FD_ISSET(listener, &amp;fds))</li>
<li class="new">      {</li>
<li class="new">         fd = tcpAccept(&amp;address, listener);</li>
<li class="new">         if (fd == -1) break;</li>
<li class="new">         printConsole("Socket %d connected.\n", fd);</li>
<li class="new">         outbufClear();</li>
<li class="new">         telnetConfigure();</li>
<li class="new">         outbufFormat("Welcome to Little Cave Adventure.\n");</li>
<li class="new">         client = clientGetFree();</li>
<li class="new">         if (client != NULL)</li>
<li class="new">         {</li>
<li class="new">            client-&gt;fd = fd;</li>
<li class="new">            client-&gt;obj = nobody;</li>
<li class="new">            telnetInit(&amp;client-&gt;inbuf);</li>
<li class="new">            telnetAppendPrompt(&amp;client-&gt;inbuf);</li>
<li class="new">         }</li>
<li class="new">         else</li>
<li class="new">         {</li>
<li class="new">            outbufFormat("All sockets occupied, please try again later.\n");</li>
<li class="new">         }</li>
<li class="new">         outbufFlush(fd);</li>
<li class="new">      }</li>
<li class="new">      for (i = 0; breakTest() &amp;&amp; (client = clientGet(i)) != NULL; i++)</li>
<li class="new">      {</li>
<li class="new">         if (FD_ISSET(client-&gt;fd, &amp;fds))</li>
<li class="new">         {</li>
<li class="new">            static char buffer[1024];</li>
<li class="new">            int len = read(client-&gt;fd, buffer, sizeof buffer);</li>
<li class="new">            if (len &gt; 0)</li>
<li class="new">            {</li>
<li class="new">               player = client-&gt;obj;</li>
<li class="new">               printSetCurrent(client-&gt;fd);</li>
<li class="new">               telnetParse(&amp;client-&gt;inbuf, client-&gt;fd, action, buffer, len);</li>
<li class="new">               if (player != client-&gt;obj)</li>
<li class="new">               {</li>
<li class="new">                  printConsole("Socket %d is %s.\n", fd, player-&gt;description);</li>
<li class="new">                  client-&gt;obj = player;</li>
<li class="new">               }</li>
<li class="new">            }</li>
<li class="new">            else if (len == 0)   </li>
<li class="new">            {</li>
<li class="new">               disconnect(client);</li>
<li class="new">            }</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   for (i = 0; (client = clientGet(i)) != NULL; i++) disconnect(client);</li>
<li class="new">   tcpClose(listener, PORT);</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 13:
I just randomly picked a port number
that was not already in use by any popular online game.
Users need this number, as well as your server&rsquo;s
(external) IP address, to connect to your game.
</li>
<li>Line 25:
function <i>server</i> has a function pointer <i>action</i> as its parameter.
Through this parameter,
we will inject the game engine we have created in the previous chapters.
</li>
<li>Line 27-28:
we start by setting up a listening
<a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>.
</li>
<li>Line 33-87:
this is the main loop of the game server.
We could stay here forever,
but sooner or later we will be forced to leave by a signal, or by an error.
</li>
<li>Line 35-43:
we build up a collection of clients that are currently connected.
</li>
<li>Line 44:
here, the process waits until some activity is detected from any of the clients.
If an error occurs, we will leave the loop. This will end the game.
</li>
<li>Line 46:
activity on the listening socket means a new client is connecting to the server.
</li>
<li>Line 48-66:
the new client is welcomed.
</li>
<li>Line 68:
looping through all the clients that are currently connected.
</li>
<li>Line 70:
any activity from this client?
</li>
<li>Line 73:
calling
<a href="https://en.wikipedia.org/wiki/Read_(system_call)">read</a>
to receive data from the client&rsquo;s
<a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>.
Here we pull in everything typed in by a user.
</li>
<li>Line 76:
in the previous chapter,
we changed <i>player</i> from a fixed object into a variable.
Here, we use this to switch to the correct
<a href="https://en.wikipedia.org/wiki/Player_character">player character</a>.
</li>
<li>Line 78:
this is the heart of the server.
It processes the client&rsquo;s input (<i>buffer</i>)
by letting our game engine (parameter <i>action</i>) execute each command,
sending responses back to client sockets.
</li>
<li>Line 79-83:
when a client first connects, they will be nobody (see line 58).
Once the game engine has established who you are,
it will be persisted here.
</li>
<li>Line 85-88:
in this context, no data means the client is disconnecting,
i.e. the user has closed the Telnet client.
</li>
<li>Line 92-93:
when leaving the main loop, close all remaining sockets.
</li>
</ul>
</div>
<p>
For readability, I implemented a number of functions in a separate module.
</p>
<table class="code"><tr>
<th>tcp.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern int tcpListen(struct sockaddr_in *addr, uint16_t port);</li>
<li class="new">extern void tcpClose(int fd, uint16_t port);</li>
<li class="new">extern int tcpSelect(int nfds, fd_set *readfds);</li>
<li class="new">extern int tcpAccept(struct sockaddr_in *addr, int listener);</li>
<li class="new">extern void tcpSend(int fd, const char *data, int len);</li>
</ol>
</td>
</tr><tr>
<th>tcp.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include &lt;stdlib.h&gt;</li>
<li class="new">#include &lt;unistd.h&gt;</li>
<li class="new">#include &lt;errno.h&gt;</li>
<li class="new">#include &lt;netinet/in.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "print.h"</li>
<li class="new"></li>
<li class="new">static int assert(const char *name, int retval)</li>
<li class="new">{</li>
<li class="new">   if (retval == -1)</li>
<li class="new">   {</li>
<li class="new">      perror(name);</li>
<li class="new">      exit(EXIT_FAILURE);</li>
<li class="new">   }</li>
<li class="new">   return retval;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">int tcpListen(struct sockaddr_in *addr, uint16_t port)</li>
<li class="new">{</li>
<li class="new">   int opt = 1;   </li>
<li class="new">   int fd = assert("socket", socket(AF_INET, SOCK_STREAM, 0));</li>
<li class="new">   assert("setsockopt", setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,</li>
<li class="new">                                   (char *)&amp;opt, sizeof opt));</li>
<li class="new">   addr-&gt;sin_family = AF_INET;</li>
<li class="new">   addr-&gt;sin_addr.s_addr = INADDR_ANY;</li>
<li class="new">   addr-&gt;sin_port = htons(port);</li>
<li class="new">   assert("bind", bind(fd, (struct sockaddr *)addr, sizeof *addr));</li>
<li class="new">   assert("listen", listen(fd, 3));</li>
<li class="new">   printConsole("Listening to port %u.\n", (unsigned int)port);</li>
<li class="new">   return fd;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void tcpClose(int fd, uint16_t port)</li>
<li class="new">{</li>
<li class="new">   close(fd);</li>
<li class="new">   printConsole("No longer listening to port %u.\n", (unsigned int)port);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">int tcpSelect(int nfds, fd_set *readfds)</li>
<li class="new">{</li>
<li class="new">   return select(nfds, readfds, NULL, NULL, NULL);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">int tcpAccept(struct sockaddr_in *addr, int listener)</li>
<li class="new">{</li>
<li class="new">   socklen_t len = sizeof *addr;</li>
<li class="new">   return assert("accept", accept(listener, (struct sockaddr *)addr, &amp;len));</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void tcpSend(int fd, const char *data, int len)</li>
<li class="new">{</li>
<li class="new">   int written;</li>
<li class="new">   while (len &gt; 0 &amp;&amp; ((written = write(fd, data, len)) &gt;= 0 || errno == EINTR))</li>
<li class="new">   {</li>
<li class="new">      if (written &gt; 0) data += written, len -= written;</li>
<li class="new">   }</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 23:
calling system call <i>socket</i>.
</li>
<li>Line 29:
calling system call <i>bind</i>.
</li>
<li>Line 30:
calling system call <i>listen</i>.
</li>
<li>Line 43:
calling system call
<a href="https://en.wikipedia.org/wiki/Select_(Unix)">select</a>.
</li>
<li>Line 49:
calling system call <i>accept</i>.
</li>
<li>Line 52-59:
function <i>tcpSend</i> will be used later in this chapter
to send output to client sockets.
</li>
</ul>
</div>
<p>
The following module provides access to an array of
<a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">structs</a>
holding information about the clients that have connected to the game.
For each client, there is a file descriptor (the
<a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>),
an object (the
<a href="https://en.wikipedia.org/wiki/Player_character">player character</a>)
and an input buffer (see <i>telnet.h</i> below).
</p>
<table class="code"><tr>
<th>client.h</th>
</tr><tr>
<td>
<ol>
<li class="new">typedef struct</li>
<li class="new">{</li>
<li class="new">   int fd;</li>
<li class="new">   OBJECT *obj;</li>
<li class="new">   INBUF inbuf;</li>
<li class="new">}</li>
<li class="new">CLIENT;</li>
<li class="new"></li>
<li class="new">extern void    clientInit(void);</li>
<li class="new">extern CLIENT *clientGet(int i);</li>
<li class="new">extern CLIENT *clientGetFree(void);</li>
</ol>
</td>
</tr><tr>
<th>client.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "telnet.h"</li>
<li class="new">#include "client.h"</li>
<li class="new"></li>
<li class="new">#define MAX_CLIENTS  30</li>
<li class="new"></li>
<li class="new">static CLIENT clients[MAX_CLIENTS];</li>
<li class="new"></li>
<li class="new">void clientInit(void)</li>
<li class="new">{</li>
<li class="new">   int i;</li>
<li class="new">   for (i = 0; i &lt; MAX_CLIENTS; i++) clients[i].fd = -1;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">CLIENT *clientGet(int i)</li>
<li class="new">{</li>
<li class="new">   return i &lt; MAX_CLIENTS ? clients + i : NULL;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">CLIENT *clientGetFree(void)</li>
<li class="new">{</li>
<li class="new">   CLIENT *client;</li>
<li class="new">   int i;</li>
<li class="new">   for (i = 0; (client = clientGet(i)) != NULL &amp;&amp; client-&gt;fd != -1; i++);</li>
<li class="new">   return client;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 11-15:
initially, all &lsquo;slots&rsquo; in the array will be empty.
</li>
<li>Line 17-20:
function <i>clientGet</i> is used to find existing clients.
</li>
<li>Line 22-28:
function <i>clientGetFree</i> is used to find a free slot.
If all slots are taken, then it will return NULL.
</li>
</ul>
</div>
<p>
The following module handles the peculiarities of the
<a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a>
protocol.
It also takes care of buffering client input
(i.e. everything typed in by the users),
and it prevents server output
(which <i>could</i> be pushed at any time by activity from other users)
getting mixed up with
<a href="https://en.wikipedia.org/wiki/Echo_(computing)">echo</a>
on the same line in the Telnet client.
</p>
<table class="code"><tr>
<th>telnet.h</th>
</tr><tr>
<td>
<ol>
<li class="new">typedef struct</li>
<li class="new">{</li>
<li class="new">   bool iac;</li>
<li class="new">   int negotiate;</li>
<li class="new">   unsigned index;</li>
<li class="new">   char data[100];</li>
<li class="new">}</li>
<li class="new">INBUF;</li>
<li class="new"></li>
<li class="new">extern void telnetInit(INBUF *inbuf);</li>
<li class="new">extern void telnetConfigure(void);</li>
<li class="new">extern void telnetInsertSpaces(INBUF *inbuf);</li>
<li class="new">extern void telnetDeleteSpaces(INBUF *inbuf);</li>
<li class="new">extern void telnetAppendPrompt(INBUF *inbuf);</li>
<li class="new">extern void telnetDeletePrompt(INBUF *inbuf);</li>
<li class="new">extern void telnetParse(INBUF *inbuf, int fd, bool (*action)(char *, int),</li>
<li class="new">                        const char *data, int length);</li>
</ol>
</td>
</tr><tr>
<th>telnet.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "outbuf.h"</li>
<li class="new">#include "telnet.h"</li>
<li class="new"></li>
<li class="new">static const char prompt[] = "--&gt; ";</li>
<li class="new"></li>
<li class="new">void telnetInit(INBUF *inbuf)</li>
<li class="new">{</li>
<li class="new">   inbuf-&gt;iac = false;</li>
<li class="new">   inbuf-&gt;negotiate = 0;</li>
<li class="new">   inbuf-&gt;index = 0;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetConfigure(void)</li>
<li class="new">{</li>
<li class="new">   static const char config[] = {</li>
<li class="new">      '\xFF', '\xFD', 34, '\xFF', '\xFA', 34, 1, 0, '\xFF', '\xF0',</li>
<li class="new">      '\xFF', '\xFB', 1</li>
<li class="new">   };</li>
<li class="new">   outbufBytes(config, sizeof config);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetInsertSpaces(INBUF *inbuf)</li>
<li class="new">{</li>
<li class="new">   outbufInsertString(0, "\r\r");</li>
<li class="new">   outbufInsertSpaces(1, inbuf-&gt;data, inbuf-&gt;index);</li>
<li class="new">   outbufInsertSpaces(1, prompt, sizeof prompt - 1);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetDeleteSpaces(INBUF *inbuf)</li>
<li class="new">{</li>
<li class="new">   outbufMove(inbuf-&gt;index + sizeof prompt + 1, 0);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetAppendPrompt(INBUF *inbuf)</li>
<li class="new">{</li>
<li class="new">   outbufBytes(prompt, sizeof prompt - 1);</li>
<li class="new">   outbufBytes(inbuf-&gt;data, inbuf-&gt;index);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetDeletePrompt(INBUF *inbuf)</li>
<li class="new">{</li>
<li class="new">   outbufRewind(inbuf-&gt;index + sizeof prompt - 1);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void telnetParse(INBUF *inbuf, int fd, bool (*action)(char *, int),</li>
<li class="new">                 const char *data, int length)</li>
<li class="new">{</li>
<li class="new">   int i;</li>
<li class="new">   outbufClear();</li>
<li class="new">   for (i = 0; i &lt; length; i++)</li>
<li class="new">   {</li>
<li class="new">      int c = data[i];</li>
<li class="new">      if (c == '\xFF' || inbuf-&gt;iac)</li>
<li class="new">      {</li>
<li class="new">         if (c == '\xF0' || inbuf-&gt;negotiate != '\xFA') inbuf-&gt;negotiate = c;</li>
<li class="new">         inbuf-&gt;iac = !inbuf-&gt;iac;</li>
<li class="new">      }</li>
<li class="new">      else if (inbuf-&gt;negotiate &gt;= '\xFA' &amp;&amp; inbuf-&gt;negotiate &lt;= '\xFE')</li>
<li class="new">      {</li>
<li class="new">         if (inbuf-&gt;negotiate != '\xFA') inbuf-&gt;negotiate = 0;</li>
<li class="new">      }</li>
<li class="new">      else if (c == '\r')</li>
<li class="new">      {</li>
<li class="new">         outbufFormat("\n");</li>
<li class="new">         outbufFlush(fd);</li>
<li class="new">         inbuf-&gt;data[inbuf-&gt;index] = '\0';</li>
<li class="new">         (*action)(inbuf-&gt;data, sizeof inbuf-&gt;data);</li>
<li class="new">         inbuf-&gt;index = 0;</li>
<li class="new">         outbufClear();</li>
<li class="new">         outbufBytes(prompt, sizeof prompt - 1);</li>
<li class="new">      }</li>
<li class="new">      else if (c == '\b' || c == '\x7F')</li>
<li class="new">      {</li>
<li class="new">         if (inbuf-&gt;index &gt; 0)</li>
<li class="new">         {</li>
<li class="new">            outbufByte('\b');</li>
<li class="new">            outbufAsSpace(inbuf-&gt;data[--inbuf-&gt;index]);</li>
<li class="new">            outbufByte('\b');</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">      else if (c &gt;= ' ' &amp;&amp; c &lt; '\x7F')</li>
<li class="new">      {</li>
<li class="new">         if (inbuf-&gt;index &lt; sizeof inbuf-&gt;data - 1)</li>
<li class="new">         {</li>
<li class="new">            outbufByte(c);</li>
<li class="new">            inbuf-&gt;data[inbuf-&gt;index++] = c;</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   outbufFlush(fd);</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 18:
<i>DO LINEMODE</i>.
Server is telling client that linemode must <i>not</i> be used.
That way, the Telnet client knows it must send every character to the server
the moment the character is typed in,
rather than save up everything until the user presses
<a href="https://en.wikipedia.org/wiki/Enter_key">enter</a>.
</li>
<li>Line 19:
<i>WILL ECHO</i>.
Server is telling client that server will
<a href="https://en.wikipedia.org/wiki/Echo_(computing)">echo</a>
every character sent by client (i.e. typed in by user).
That way, the Telnet client knows it must <i>not</i> do a local echo.
</li>
<li>Line ?:
?
</li>
<li>Line ?:
?
</li>
</ul>
</div>
<p>
Output may need to go to more than one client.
</p>
<table class="code"><tr>
<th>print.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern void printSetCurrent(int fd);</li>
<li class="new">extern void printConsole(const char *format, ...);</li>
<li class="new">extern void printPrivate(const char *format, ...);</li>
<li class="new">extern void printSee(const char *format, ...);</li>
<li class="new">extern void printAny(OBJECT *obj1, OBJECT *obj2, const char *sense,</li>
<li class="new">                     const char *format, ...);</li>
</ol>
</td>
</tr><tr>
<th>print.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdarg.h&gt;</li>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include &lt;unistd.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "outbuf.h"</li>
<li class="new">#include "telnet.h"</li>
<li class="new">#include "client.h"</li>
<li class="new"></li>
<li class="new">#define VA(print)  va_list ap; va_start(ap, format); print; va_end(ap)</li>
<li class="new"></li>
<li class="new">static int currentSocket = STDOUT_FILENO;</li>
<li class="new"></li>
<li class="new">static bool filter(OBJECT *obj, OBJECT *obj1, OBJECT *obj2)</li>
<li class="new">{</li>
<li class="new">   return obj2 == NULL ? obj == obj1 : obj != obj1 &amp;&amp; obj != obj2;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void printDemux(OBJECT *obj1, OBJECT *obj2)</li>
<li class="new">{</li>
<li class="new">   if (currentSocket == STDOUT_FILENO)</li>
<li class="new">   {</li>
<li class="new">      if (filter(player, obj1, obj2)) outbufFlush(STDOUT_FILENO);</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      CLIENT *client;</li>
<li class="new">      int i;</li>
<li class="new">      for (i = 0; (client = clientGet(i)) != NULL; i++)</li>
<li class="new">      {</li>
<li class="new">         if (client-&gt;fd != -1 &amp;&amp; client-&gt;obj-&gt;location == player-&gt;location &amp;&amp;</li>
<li class="new">             filter(client-&gt;obj, obj1, obj2))</li>
<li class="new">         {</li>
<li class="new">            if (client-&gt;fd == currentSocket)</li>
<li class="new">            {</li>
<li class="new">               outbufFlush(client-&gt;fd);</li>
<li class="new">            }</li>
<li class="new">            else</li>
<li class="new">            {</li>
<li class="new">               telnetInsertSpaces(&amp;client-&gt;inbuf);</li>
<li class="new">               telnetAppendPrompt(&amp;client-&gt;inbuf);</li>
<li class="new">               outbufFlush(client-&gt;fd);</li>
<li class="new">               telnetDeletePrompt(&amp;client-&gt;inbuf);</li>
<li class="new">               telnetDeleteSpaces(&amp;client-&gt;inbuf);</li>
<li class="new">            }</li>
<li class="new">         }</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void printObserve(OBJECT *obj1, OBJECT *obj2, const char *sense,</li>
<li class="new">                         const char *format, va_list ap)</li>
<li class="new">{</li>
<li class="new">   outbufClear();</li>
<li class="new">   outbufFormatVar(format, ap);</li>
<li class="new">   if (obj1 != obj2)</li>
<li class="new">   {</li>
<li class="new">      printDemux(obj1, NULL);</li>
<li class="new">   }</li>
<li class="new">   if (sense != NULL)</li>
<li class="new">   {</li>
<li class="new">      outbufInsertString(3, obj1-&gt;description);</li>
<li class="new">      outbufInsertString(3, sense);</li>
<li class="new">      printDemux(obj2, obj1);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">static void printFd(int fd, const char *format, va_list ap)</li>
<li class="new">{</li>
<li class="new">   outbufClear();</li>
<li class="new">   outbufFormatVar(format, ap);</li>
<li class="new">   outbufFlush(fd);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void printSetCurrent(int fd)</li>
<li class="new">{</li>
<li class="new">   currentSocket = fd;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void printConsole(const char *format, ...)</li>
<li class="new">{</li>
<li class="new">   VA(printFd(STDOUT_FILENO, format, ap));</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void printPrivate(const char *format, ...)</li>
<li class="new">{</li>
<li class="new">   VA(printFd(currentSocket, format, ap));</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void printSee(const char *format, ...)</li>
<li class="new">{</li>
<li class="new">   VA(printObserve(player, NULL, " see ", format, ap));</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void printAny(OBJECT *obj1, OBJECT *obj2, const char *sense,</li>
<li class="new">              const char *format, ...)</li>
<li class="new">{</li>
<li class="new">   VA(printObserve(obj1, obj2, sense, format, ap));</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line ?:
?
</li>
<li>Line ?:
?
</li>
</ul>
</div>
<p>
Making output ready to be sent to a socket.
</p>
<table class="code"><tr>
<th>outbuf.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern void outbufClear(void);</li>
<li class="new">extern void outbufRewind(int len);</li>
<li class="new">extern void outbufByte(char c);</li>
<li class="new">extern void outbufBytes(const char *data, int length);</li>
<li class="new">extern void outbufAsSpace(char c);</li>
<li class="new">extern void outbufFormatVar(const char *format, va_list ap);</li>
<li class="new">extern void outbufFormat(const char *format, ...);</li>
<li class="new">extern bool outbufStartsWith(const char *prefix, int len);</li>
<li class="new">extern bool outbufMove(int from, int to);</li>
<li class="new">extern void outbufInsertString(int pos, const char *string);</li>
<li class="new">extern void outbufInsertSpaces(int pos, const char *data, int len);</li>
<li class="new">extern void outbufFlush(int fd);</li>
</ol>
</td>
</tr><tr>
<th>outbuf.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;ctype.h&gt;</li>
<li class="new">#include &lt;stdarg.h&gt;</li>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include &lt;string.h&gt;</li>
<li class="new">#include &lt;netinet/in.h&gt;</li>
<li class="new">#include "tcp.h"</li>
<li class="new"></li>
<li class="new">#define MAX_LEN  4095</li>
<li class="new"></li>
<li class="new">static int outbufLen;</li>
<li class="new">static char outbufData[MAX_LEN + 1];</li>
<li class="new"></li>
<li class="new">static int asSpace(int c)</li>
<li class="new">{</li>
<li class="new">   return isspace(c) ? c : ' ';</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufClear(void)</li>
<li class="new">{</li>
<li class="new">   outbufLen = 0;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufRewind(int len)</li>
<li class="new">{</li>
<li class="new">   outbufLen -= len;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufByte(char c)</li>
<li class="new">{</li>
<li class="new">   if (outbufLen &lt; MAX_LEN) outbufData[outbufLen++] = c;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufBytes(const char *data, int length)</li>
<li class="new">{</li>
<li class="new">   for (; length &gt; 0; length--) outbufByte(*data++);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufAsSpace(char c)</li>
<li class="new">{</li>
<li class="new">   outbufByte(asSpace(c));</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufFormatVar(const char *format, va_list ap)</li>
<li class="new">{</li>
<li class="new">   char *ptr = outbufData + outbufLen;</li>
<li class="new">   outbufLen += vsnprintf(ptr, sizeof outbufData - outbufLen, format, ap);</li>
<li class="new">   if (outbufLen &gt; MAX_LEN) outbufLen = MAX_LEN;</li>
<li class="new">   while (outbufLen &lt; MAX_LEN &amp;&amp; (ptr = strchr(ptr, '\n')) != NULL)</li>
<li class="new">   {</li>
<li class="new">      memmove(ptr + 1, ptr, outbufData + ++outbufLen - ptr);</li>
<li class="new">      *ptr = '\r';</li>
<li class="new">      ptr += 2;</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufFormat(const char *format, ...)</li>
<li class="new">{</li>
<li class="new">   va_list ap;</li>
<li class="new">   va_start(ap, format);</li>
<li class="new">   outbufFormatVar(format, ap);</li>
<li class="new">   va_end(ap);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool outbufStartsWith(const char *prefix, int len)</li>
<li class="new">{</li>
<li class="new">   return outbufLen &gt;= len &amp;&amp; strncmp(outbufData, prefix, len) == 0;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool outbufMove(int from, int to)</li>
<li class="new">{</li>
<li class="new">   outbufLen += to - from;</li>
<li class="new">   if (outbufLen &gt; MAX_LEN) outbufLen = MAX_LEN;</li>
<li class="new">   if (to &lt; outbufLen)</li>
<li class="new">   {</li>
<li class="new">      memmove(outbufData + to, outbufData + from, outbufLen - to);</li>
<li class="new">   }</li>
<li class="new">   return to &lt;= outbufLen;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufInsertString(int pos, const char *string)</li>
<li class="new">{</li>
<li class="new">   int len = strlen(string);</li>
<li class="new">   if (outbufMove(pos, pos + len)) strncpy(outbufData + pos, string, len);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufInsertSpaces(int pos, const char *data, int len)</li>
<li class="new">{</li>
<li class="new">   if (outbufMove(pos, pos + len))</li>
<li class="new">   {</li>
<li class="new">      int i;</li>
<li class="new">      for (i = 0; i &lt; len; i++) outbufData[pos + i] = asSpace(data[i]);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void outbufFlush(int fd)</li>
<li class="new">{</li>
<li class="new">   tcpSend(fd, outbufData, outbufLen);</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line ?:
?
</li>
<li>Line ?:
?
</li>
</ul>
</div>
<p>
Allow for a graceful exit
in case the process is forced to stop by an outside signal.
</p>
<table class="code"><tr>
<th>break.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern void breakInit(void);</li>
<li class="new">extern bool breakTest(void);</li>
</ol>
</td>
</tr><tr>
<th>break.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;string.h&gt;</li>
<li class="new">#include &lt;signal.h&gt;</li>
<li class="new"></li>
<li class="new">static volatile sig_atomic_t done = 0;</li>
<li class="new"></li>
<li class="new">static void handler(int signum)</li>
<li class="new">{</li>
<li class="new">   done = signum;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">void breakInit(void)</li>
<li class="new">{</li>
<li class="new">   struct sigaction action;</li>
<li class="new">   memset(&amp;action, 0, sizeof(action));</li>
<li class="new">   action.sa_handler = handler;</li>
<li class="new">   sigaction(SIGINT, &amp;action, NULL);</li>
<li class="new">   sigaction(SIGTERM, &amp;action, NULL);</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool breakTest(void)</li>
<li class="new">{</li>
<li class="new">   return done == 0;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line ?:
?
</li>
<li>Line ?:
?
</li>
</ul>
</div>
<p>
Start running the server after an initial single-user session
allowing the game administrator to set up things in the game.
</p>
<table class="code"><tr>
<th>main.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include &lt;string.h&gt;</li>
<li class="new"><span class="old">#include </span>"object.h"</li>
<li class="new">#include "print.h"</li>
<li class="new">#include<span class="old"> "expand.h"</span></li>
<li class="old">#include "parsexec.h"</li>
<li class="old">#include "turn.h"</li>
<li class="new">#include "server.h"</li>
<li class="old"></li>
<li class="old">static char input[100] = "look around";</li>
<li class="old"></li>
<li class="old">static bool getFromFP(FILE *fp)</li>
<li class="old">{</li>
<li class="old">   bool ok = fgets(input, sizeof input, fp) != NULL;</li>
<li class="old">   if (ok) input[strcspn(input, "\n")] = '\0';</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool getInput(const char *filename)</li>
<li class="old">{</li>
<li class="old">   static FILE *fp = NULL;</li>
<li class="old">   bool ok;</li>
<li class="old">   if (fp == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (filename != NULL) fp = fopen(filename, "rt");</li>
<li class="old">      if (fp == NULL) fp = stdin;</li>
<li class="old">   }</li>
<li class="old">   else if (fp == stdin &amp;&amp; filename != NULL)</li>
<li class="old">   {</li>
<li class="old">      FILE *out = fopen(filename, "at");</li>
<li class="old">      if (out != NULL)</li>
<li class="old">      {</li>
<li class="old">         fprintf(out, "%s\n", input);</li>
<li class="old">         fclose(out);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="new"><span class="old">   </span>printConsole("\n--&gt;<span class="old"> ");</span></li>
<li class="old">   ok = getFromFP(fp);</li>
<li class="old">   if (fp != stdin)</li>
<li class="old">   {</li>
<li class="old">      if (ok)</li>
<li class="old">      {</li>
<li class="new"><span class="old">         </span>printConsole("%s\n",<span class="old"> input);</span></li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         fclose(fp);</li>
<li class="old">         ok = getFromFP(fp = stdin);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return ok;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool processInput(char *ptr, int size)</li>
<li class="old">{</li>
<li class="old">   return turn(parseAndExecute(expand(ptr, size)));</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">int main(int argc, char *argv[])</li>
<li class="old">{</li>
<li class="old">   (void)argc;</li>
<li class="new"><span class="old">   </span>printConsole("Welcome<span class="old"> to Little Cave Adventure.\n");</span></li>
<li class="new"><span class="old">   </span>printConsole("You are in single-user mode; enter 'quit' for multi-user.\n");</li>
<li class="new">   player = nobody;</li>
<li class="old">   while (processInput(input, sizeof input) &amp;&amp; getInput(argv[1]));</li>
<li class="new"><span class="old">   </span>printConsole("\nGoing into multi-user mode; press ^C to stop.\n");</li>
<li class="new">   server(processInput);</li>
<li class="new">   printConsole("\nBye!\n");</li>
<li class="old">   return 0;</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line ?:
?
</li>
<li>Line ?:
?
</li>
</ul>
</div>
<p>
By today&rsquo;s standards,
our program can hardly be called a mature game server.
It has several flaws:
</p>
<ul>
<li>No
<a href="https://en.wikipedia.org/wiki/Authentication">authentication</a>.
This could be fixed by demanding a password to be included
in command <i>play</i>.
</li>
<li>Vulnerable to
<a href="https://en.wikipedia.org/wiki/Network_eavesdropping">eavesdropping</a>:
everything is transmitted unencrypted, including passwords!
This could be fixed with
<a href="https://en.wikipedia.org/wiki/Tcpcrypt">tcpcrypt</a>
or with a secure tunnel (through
<a href="https://en.wikipedia.org/wiki/Tunneling_protocol#SSH">SSH</a> or
<a href="https://en.wikipedia.org/wiki/Virtual_private_network">VPN</a>).
</li>
<li>Vulnerable to
<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle attacks</a>.
Again, a user&rsquo;s password could be intercepted.
To mitigate that, you&rsquo;d need certificates.
</li>
<li>Does not
<a href="https://en.wikipedia.org/wiki/Scalability">scale</a>
well. First of all,
<a href="https://en.wikipedia.org/wiki/Select_(Unix)">select</a>
suffers from the
<a href="https://en.wikipedia.org/wiki/C10k_problem">C10k problem</a>
and should be replaced by
<a href="https://en.wikipedia.org/wiki/Kqueue">kqueue</a> or
<a href="https://en.wikipedia.org/wiki/Epoll">epoll</a>.
Secondly, it is not straightforward to scale out to multiple
<a href="https://en.wikipedia.org/wiki/Node_(networking)">nodes</a>.
A solution might be to partition the game into multiple &lsquo;worlds.&rsquo;
</li>
</ul>
<p>
It would make more sense to turn the whole game into a web application.
For that, it&rsquo;s probably best to port the program to
a different programming language, for example JavaScript.
We will give that a shot in chapter 25.
</p>
<hr />
<table class="download"><tr><td>
<a class="button" href="code22/src.zip">&#x2B73; &nbsp; Download source code</a>
<a class="button" href="https://repl.it/github/helderman/htpataic">&#x1F300; &nbsp; Run on Repl.it</a>
</td></tr></table>
<p>
Next chapter: <a href="htpataic23.html">23. Database</a>
</p>
</body>
</html>
