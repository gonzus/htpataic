<!DOCTYPE html>
<html>
<head>
<title>19. Conversations</title>
<link rel="stylesheet" href="htpataic.css" type="text/css" />
</head>
<body>
<table class="contents"><tr><td>
<h4>Contents</h4>
<div><a href="htpataic01.html">1. Introduction</a></div>
<div><a href="htpataic02.html">2. The main loop</a></div>
<div><a href="htpataic03.html">3. Locations</a></div>
<div><a href="htpataic04.html">4. Objects</a></div>
<div><a href="htpataic05.html">5. Inventory</a></div>
<div><a href="htpataic06.html">6. Passages</a></div>
<div><a href="htpataic07.html">7. Distance</a></div>
<div><a href="htpataic08.html">8. North, east, south, west</a></div>
<div><a href="htpataic09.html">9. Code generation</a></div>
<div><a href="htpataic10.html">10. More attributes</a></div>
<div><a href="htpataic11.html">11. Conditions</a></div>
<div><a href="htpataic12.html">12. Open and close</a></div>
<div><a href="htpataic13.html">13. The parser</a></div>
<div><a href="htpataic14.html">14. Multiple nouns</a></div>
<div><a href="htpataic15.html">15. Light and dark</a></div>
<div><a href="htpataic16.html">16. Savegame</a></div>
<div><a href="htpataic17.html">17. Test automation</a></div>
<div><a href="htpataic18.html">18. Abbreviations</a></div>
<div><b>19. Conversations</b></div>
<div><a href="htpataic20.html">20. Combat</a></div>
<div><a href="htpataic21.html">21. Database</a></div>
<div><a href="htpataic22.html">22. Speech</a></div>
<div><a href="htpataic23.html">23. JavaScript</a></div>
</td></tr></table>

<h1>How to program a text adventure in C</h1>
<p>
by Ruud Helderman
&lt;<a href="mailto:r.helderman@hccnet.nl">r.helderman@hccnet.nl</a>&gt;
</p>
<p>
Licensed under
<a href="https://github.com/helderman/htpataic/blob/master/LICENSE">MIT License</a>
</p>
<h2>19. Conversations</h2>
<p class="intro">
One of the most difficult parts of writing an adventure
is to come up with challenging puzzles.
Puzzles must be difficult, but without being illogical.
If your game demands the player to unlock a door with a towel, fine.
But then at least give the player a clue.
It&rsquo;s no fun brute-forcing your way through a game,
having to try every combination of object(s) and verb until you find
something that matches the author&rsquo;s obscure sense of logic.
</p>
<p>
Clues can be hidden in descriptive text.
This text may come out unannounced,
for example as you enter a location
(&ldquo;A hollow voice says
<a href="https://en.wikipedia.org/wiki/Colossal_Cave_Adventure#Plugh">PLUGH</a>&rdquo;)
or run into an actor.
But it also makes sense to let the player actively search for clues
by examining objects and talking to non-player characters.
Obvious advantages are:
</p>
<ul>
<li>It gives the player a sense of being actively involved in the story.
In a detective story,
examining the crime scene and interrogating witnesses and suspects
should play a vital role in solving the mystery.
</li>
<li>It is a natural way to split descriptive text into smaller chunks,
and serving the information in an on-demand fashion to the player.
This prevents a waterfall of (unsolicited) information
at certain (fixed) points in the game.
</li>
</ul>
<p>
Conversation with non-player characters can add a lot of depth to a game.
Clues given may help you or hinder you.
Some examples:
</p>
<ul>
<li>When entering a town, the locals may be able to tell you
how to earn money, where to find food, or how to sneak into the castle.
The more focused the inquiry
(referring to a relevant item, location or actor),
the more focused the information returned.
Like in real life, it&rsquo;s all about asking the right questions.
</li>
<li>Information gathered from different sources
may be interrelated or contradictory.
The baker may have given you some useful gossip,
but what if the goldsmith told you the baker is actually a notorious liar?
</li>
<li>The player may need to &lsquo;encourage&rsquo; actors to spill their guts.
Either with a friendly gesture (is there some item they need?) or by force.
An actor&rsquo;s willingness to supply (valid) information
could be implemented by certain &lsquo;psychological&rsquo; properties,
rating their loyalty or fear towards the player.
</li>
</ul>
<p>
Conversations may go a lot further than just asking for information.
Some suggestions:
</p>
<ul>
<li>Allow the player to give commands to other actors,
for example: &ldquo;Tell giant to break door with axe.&rdquo;
So rather than taking action yourself,
you could try and find a &lsquo;specialist&rsquo; to do the job.
Whether or not other actors will obey your commands, might depend
on the effort you have put into building a certain relationship with them.
</li>
<li>Allow the player to pass information back to other actors.
You may not be strong enough to push aside a pair of guards,
but it might help to use a little lie to spark a conflict between them.
</li>
</ul>
<p>
Of course, these more advanced forms of interacting with actors
demand a pretty sophisticated conversation engine.
A recommended read is
<i>Dynamic Conversation Engine Concept</i> by Luke Bergeron.
I found this to be incredibly inspiring.
The article has been removed from
<a href="https://en.wikipedia.org/wiki/Scribd">Scribd</a>,
but fortunately the
<a href="https://en.wikipedia.org/wiki/Wayback_Machine">Wayback Machine</a>
still has a copy:<br />
<a href="https://web.archive.org/web/20100409073709/http://www.scribd.com/doc/17682546/Dynamic-Conversation-Engine-Concept">https://web.archive.org/web/20100409073709/http://www.scribd.com/doc/17682546/Dynamic-Conversation-Engine-Concept</a>
</p>
<h3>Talk</h3>
<p>
In our little adventure game, we will try to keep it simple.
We will implement a very straightforward &lsquo;talk&rsquo; verb.
It allows the player to talk with an actor about some topic.
The topic of discussion can be any object:
an item, a location, even another actor.
In its most elaborate form,
you could give every actor their own opinion about certain topics.
That requires a matrix of possible reactions;
one for every combination of actor and object.
</p>
<table cellpadding="8">
<tr>
<th></th>
<th>Tour guide</th>
<th>Guard</th>
</tr>
<tr>
<th>Cave</th>
<td class="comment">&ldquo;A unique experience for you to see!&rdquo;</td>
<td class="comment">&ldquo;Sorry, we&rsquo;re closed.&rdquo;</td>
</tr>
<tr>
<th>Silver coin</th>
<td class="comment">&ldquo;You found a coin? That brings good luck!&rdquo;</td>
<td class="comment">&ldquo;Maybe we can arrange something for you...&rdquo;</td>
</tr>
<tr>
<th>Gold coin</th>
<td class="comment">&ldquo;Rumor has it there&rsquo;s treasure in the caves.&rdquo;</td>
<td class="comment">&ldquo;You will have to find a key first...&rdquo;</td>
</tr>
<th>Tour guide</th>
<td class="comment">&ldquo;Sorry, I just can&rsquo;t stop talking!&rdquo;</td>
<td class="comment">&ldquo;Too slick, if you ask me.&rdquo;</td>
</tr>
<th>Guard</th>
<td class="comment">&ldquo;When the price is right, he&rsquo;s your man!&rdquo;</td>
<td class="comment">&ldquo;I&rsquo;m not in the mood to talk about myself.&rdquo;</td>
</tr>
</table>
<p>
In a big adventure, such a matrix could be huge,
making it extremely time-consuming for the author to come up with
a witty response on every attempt from the player to engage in conversation.
Furthermore, a huge number of combinations
could easily turn into just another brute-force puzzle, where the player
feels forced to interrogate every actor about every possible topic.
</p>
<p>
To keep it maintainable,
you may want to cut down on the number of combinations.
Here are a few ways to do so.
</p>
<ul>
<li><b>Eliminate actors from the matrix.</b>
Some actors may be unable to speak (e.g. animals),
not willing to speak (enemies), or both (monsters).
Those actors do not belong in the matrix;
a single uniform response per actor should suffice.
(&ldquo;The dog replies: woof woof woof.&rdquo;)
An exceptional response to one particular topic
could be handled in a hard-coded way.
(&ldquo;When hearing the word &lsquo;rosebud&rsquo;,
the dog starts to growl.&rdquo;)
</li>
<li><b>Eliminate objects from the matrix.</b>
For many (or even all) objects, you may want to supply a single response,
to be returned by every (talkative) actor.
(&ldquo;You get the advice: do not fight with the guard!&rdquo;)
Again, if there is an exceptional answer, to be given by a particular actor,
then that can be hard-coded.
(&ldquo;The tour guide says: do not forget to pay the guard!&rdquo;)
</li>
<li><b>Group actors.</b>
Instead of giving every individual its own column in the matrix,
use &lsquo;categories&rsquo; of actors.
There may be many different villagers,
but if they all share the same basic knowledge about the majority of topics,
then this will save you a lot of duplicate entries.
Again, exceptions to the rule can be hard-coded.
</li>
<li><b>Multiple smaller matrices.</b>
Suppose the game is set in a big world
where the player roams from village to village.
Villagers may not be aware of items, locations and actors in other villages.
Giving each village its own matrix, eliminates all the irrelevant cross-village combinations.
(A mathematician might refer to this approach as a
<a href="https://en.wikipedia.org/wiki/Block_matrix#Block_diagonal_matrices">block diagonal matrix</a>.)
</li>
<li><b>Sparse matrix.</b>
All the previous approaches had one disadvantage:
there is no structural solution for exceptional combinations of actor and object
(that one actor to give the player the essential clue about that one object).
But there is an alternative to 'hard-coding' the exceptions:
put these combinations in a separate
<a href="https://en.wikipedia.org/wiki/Sparse_matrix">sparse matrix</a>.
Such a matrix would typically be implemented not as a two-dimensional array,
but as a list of tuples.
Covering exceptional cases only, the list should be relatively short,
which helps to keep it compact and maintainable.
</li>
</ul>
TODO: properties 'loyalty' and 'confidentiality'.
Only spill gossip if object's confidentiality &lt; actor's loyalty.
<p>
To keep things simple, we will stick to a single response per object,
given by any actor the player will talk to about that object.
</p>
<table class="demo">
<tr><th>Sample output</th></tr>
<tr><td>
Welcome to Little Cave Adventure.<br />
You are in an open field.<br />
You see:<br />
a silver coin<br />
a burly guard<br />
a cave entrance to the east<br />
dense forest all around<br />
a lamp<br />
<br />
--&gt; talk with guard<br />
I don't understand what you want to talk about.<br />
<br />
--&gt; talk about coin<br />
You hear a burly guard say: 'Money makes the world go round...'<br />
<br />
--&gt; talk with guard about forest<br />
You hear a burly guard say: 'You cannot go there, it is impenetrable.'<br />
<br />
--&gt; talk about cave<br />
You hear a burly guard say: 'It's dark in there; bring a lamp!'<br />
<br />
--&gt; talk about east<br />
You hear a burly guard say: 'It's just a compass direction.'<br />
<br />
--&gt; talk about yourself<br />
You hear a burly guard say: 'You're not from around here, are you?'<br />
<br />
--&gt; talk about guard<br />
You hear a burly guard say: 'I don't want to talk about myself.'<br />
<br />
--&gt; talk about hamburgers<br />
I don't understand what you want to talk about.<br />
<br />
--&gt; talk<br />
I don't understand what you want to talk about.<br />
<br />
--&gt; quit<br />
<br />
Bye!<br />
</td></tr>
</table>
<table class="code"><tr>
<th>object.txt</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "toggle.h"</li>
<li class="old"></li>
<li class="old">typedef struct object {</li>
<li class="old">   bool         (*condition)(void);</li>
<li class="old">   const char    *description;</li>
<li class="old">   const char   **tags;</li>
<li class="old">   struct object *location;</li>
<li class="old">   struct object *destination;</li>
<li class="old">   struct object *prospect;</li>
<li class="old">   const char    *details;</li>
<li class="old">   const char    *contents;</li>
<li class="old">   const char    *textGo;</li>
<li class="new">   const char    *gossip;</li>
<li class="old">   int            weight;</li>
<li class="old">   int            capacity;</li>
<li class="old">   int            health;</li>
<li class="old">   int            light;</li>
<li class="old">   void         (*open)(void);</li>
<li class="old">   void         (*close)(void);</li>
<li class="old">   void         (*lock)(void);</li>
<li class="old">   void         (*unlock)(void);</li>
<li class="old">} OBJECT;</li>
<li class="old"></li>
<li class="old">extern OBJECT objs[];</li>
<li class="old"></li>
<li class="new">- gossipEWNS</li>
<li class="new">     tags        "east", "west", "north", "south"</li>
<li class="new">     gossip      "It's just a compass direction."</li>
<li class="new"></li>
<li class="old">- field</li>
<li class="old">     description "an open field"</li>
<li class="old">     tags        "field"</li>
<li class="old">     details     "The field is a nice and quiet place under a clear blue sky.\n"</li>
<li class="new">     gossip      "A lot of tourists go there."</li>
<li class="old">     capacity    9999</li>
<li class="old">     light       100</li>
<li class="old"></li>
<li class="old">- cave</li>
<li class="old">     description "a little cave"</li>
<li class="old">     tags        "cave"</li>
<li class="old">     details     "The cave is just a cold, damp, rocky chamber.\n"</li>
<li class="new">     gossip      "It's dark in there; bring a lamp!"</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- silver</li>
<li class="old">     description "a silver coin"</li>
<li class="old">     tags        "silver", "coin", "silver coin"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The coin has an eagle on the obverse.\n"</li>
<li class="new">     gossip      "Money makes the world go round..."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- gold</li>
<li class="old">     description "a gold coin"</li>
<li class="old">     tags        "gold", "coin", "gold coin"</li>
<li class="old">     location    openBox</li>
<li class="old">     details     "The shiny coin seems to be a rare and priceless artefact.\n"</li>
<li class="new">     gossip      "Money makes the world go round..."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- guard</li>
<li class="old">     description "a burly guard"</li>
<li class="old">     tags        "guard", "burly guard"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The guard is a really big fellow.\n"</li>
<li class="new">     gossip      "Easy to bribe..."</li>
<li class="old">     contents    "He has"</li>
<li class="old">     health      100</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- player</li>
<li class="old">     description "yourself"</li>
<li class="old">     tags        "yourself"</li>
<li class="old">     location    field</li>
<li class="old">     details     "You would need a mirror to look at yourself.\n"</li>
<li class="new">     gossip      "You're not from around here, are you?"</li>
<li class="old">     contents    "You have"</li>
<li class="old">     health      100</li>
<li class="old">     capacity    20</li>
<li class="old"></li>
<li class="old">- intoCave</li>
<li class="old">     condition   { return guard-&gt;health == 0 || silver-&gt;location == guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop.\n"</li>
<li class="old">     textGo      "You walk into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- intoCaveBlocked</li>
<li class="old">     condition   { return guard-&gt;health &gt; 0 &amp;&amp; silver-&gt;location != guard; }</li>
<li class="old">     description "a cave entrance to the east"</li>
<li class="old">     tags        "east", "entrance"</li>
<li class="old">     location    field</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The entrance is just a narrow opening in a small outcrop.\n"</li>
<li class="old">     textGo      "The guard stops you from walking into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- exitCave</li>
<li class="old">     description "an exit to the west"</li>
<li class="old">     tags        "west", "exit"</li>
<li class="old">     location    cave</li>
<li class="old">     destination field</li>
<li class="old">     details     "Sunlight pours in through an opening in the cave's wall.\n"</li>
<li class="old">     textGo      "You walk out of the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- wallField</li>
<li class="old">     description "dense forest all around"</li>
<li class="old">     tags        "west", "north", "south", "forest"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The field is surrounded by trees and undergrowth.\n"</li>
<li class="old">     textGo      "Dense forest is blocking the way.\n"</li>
<li class="new">     gossip      "You cannot go there, it is impenetrable."</li>
<li class="old"></li>
<li class="old">- wallCave</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "north", "rock"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "Carved in stone is a secret password 'abccb'.\n"</li>
<li class="old">     textGo      "Solid rock is blocking the way.\n"</li>
<li class="old"></li>
<li class="old">- backroom</li>
<li class="old">     description "a backroom"</li>
<li class="old">     tags        "backroom"</li>
<li class="old">     details     "The room is dusty and messy.\n"</li>
<li class="new">     gossip      "There is something of value to be found there."</li>
<li class="old">     capacity    9999</li>
<li class="old"></li>
<li class="old">- wallBackroom</li>
<li class="old">     description "solid rock all around"</li>
<li class="old">     tags        "east", "west", "south", "rock"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "Trendy wallpaper covers the rock walls.\n"</li>
<li class="old">     textGo      "Solid rock is blocking the way.\n"</li>
<li class="old"></li>
<li class="old">- openDoorToBackroom</li>
<li class="old">     description "an open door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     destination backroom</li>
<li class="old">     details     "The door is open.\n"</li>
<li class="old">     textGo      "You walk through the door into a backroom.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleDoorToBackroom</li>
<li class="old"></li>
<li class="old">- closedDoorToBackroom</li>
<li class="old">     description "a closed door to the south"</li>
<li class="old">     tags        "south", "door", "doorway"</li>
<li class="old">     location    cave</li>
<li class="old">     prospect    backroom</li>
<li class="old">     details     "The door is closed.\n"</li>
<li class="old">     textGo      "The door is closed.\n"</li>
<li class="old">     open        toggleDoorToBackroom</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openDoorToCave</li>
<li class="old">     description "an open door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     destination cave</li>
<li class="old">     details     "The door is open.\n"</li>
<li class="old">     textGo      "You walk through the door into the cave.\n"</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleDoorToCave</li>
<li class="old"></li>
<li class="old">- closedDoorToCave</li>
<li class="old">     description "a closed door to the north"</li>
<li class="old">     tags        "north", "door", "doorway"</li>
<li class="old">     location    backroom</li>
<li class="old">     prospect    cave</li>
<li class="old">     details     "The door is closed.\n"</li>
<li class="old">     textGo      "The door is closed.\n"</li>
<li class="old">     open        toggleDoorToCave</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old"></li>
<li class="old">- openBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is open.\n"</li>
<li class="new">     gossip      "You need a key to open it."</li>
<li class="old">     weight      5</li>
<li class="old">     capacity    10</li>
<li class="old">     open        isAlreadyOpen</li>
<li class="old">     close       toggleBox</li>
<li class="old">     lock        isStillOpen</li>
<li class="old">     unlock      isAlreadyOpen</li>
<li class="old"></li>
<li class="old">- closedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     details     "The box is closed.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     open        toggleBox</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        toggleBoxLock</li>
<li class="old">     unlock      isAlreadyUnlocked</li>
<li class="old"></li>
<li class="old">- lockedBox</li>
<li class="old">     description "a wooden box"</li>
<li class="old">     tags        "box", "wooden box"</li>
<li class="old">     location    backroom</li>
<li class="old">     details     "The box is closed.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     open        isStillLocked</li>
<li class="old">     close       isAlreadyClosed</li>
<li class="old">     lock        isAlreadyLocked</li>
<li class="old">     unlock      toggleBoxLock</li>
<li class="old"></li>
<li class="old">- keyForBox</li>
<li class="old">     description "a tiny key"</li>
<li class="old">     tags        "key", "tiny key"</li>
<li class="old">     location    cave</li>
<li class="old">     details     "The key is really small and shiny.\n"</li>
<li class="new">     gossip      "A small key opens a small lock."</li>
<li class="old">     weight      1</li>
<li class="old"></li>
<li class="old">- lampOff</li>
<li class="old">     description "a lamp"</li>
<li class="old">     tags        "lamp"</li>
<li class="old">     location    field</li>
<li class="old">     details     "The lamp is off.\n"</li>
<li class="new">     gossip      "Essential in dark areas."</li>
<li class="old">     weight      5</li>
<li class="old"></li>
<li class="old">- lampOn</li>
<li class="old">     description "a lamp"</li>
<li class="old">     tags        "lamp"</li>
<li class="old">     details     "The lamp is on.\n"</li>
<li class="old">     weight      5</li>
<li class="old">     light       100</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 16:
the new property.
</li>
<li>Line 29-31:
introducing a dummy object to prevent generic tags
(in this case east, west, north, south) to be handled by a specific object
(for example the forest).
</li>
</ul>
</div>
<p>
As always, we also need to make <i>object.awk</i> aware of the new property,
and specify a default value.
</p>
<table class="code"><tr>
<th>object.awk</th>
</tr><tr>
<td>
<ol>
<li class="old">BEGIN {</li>
<li class="old">   count = 0;</li>
<li class="old">   obj = "";</li>
<li class="old">   if (pass == "c2") {</li>
<li class="old">      print "\nstatic bool alwaysTrue(void) { return true; }";</li>
<li class="old">      print "\nOBJECT objs[] = {";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">/^- / {</li>
<li class="old">   outputRecord(",");</li>
<li class="old">   obj = $2;</li>
<li class="old">   prop["condition"]   = "alwaysTrue";</li>
<li class="old">   prop["description"] = "NULL";</li>
<li class="old">   prop["tags"]        = "";</li>
<li class="old">   prop["location"]    = "NULL";</li>
<li class="old">   prop["destination"] = "NULL";</li>
<li class="old">   prop["prospect"]    = "";</li>
<li class="old">   prop["details"]     = "\"You see nothing special.\\n\"";</li>
<li class="old">   prop["contents"]    = "\"You see\"";</li>
<li class="old">   prop["textGo"]      = "\"You can't get much closer than this.\\n\"";</li>
<li class="new">   prop["gossip"]      = "\"I know nothing about that.\"";</li>
<li class="old">   prop["weight"]      = "99";</li>
<li class="old">   prop["capacity"]    = "0";</li>
<li class="old">   prop["health"]      = "0";</li>
<li class="old">   prop["light"]       = "0";</li>
<li class="old">   prop["open"]        = "cannotBeOpened";</li>
<li class="old">   prop["close"]       = "cannotBeClosed";</li>
<li class="old">   prop["lock"]        = "cannotBeLocked";</li>
<li class="old">   prop["unlock"]      = "cannotBeUnlocked";</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">obj &amp;&amp; /^[ \t]+[a-z]/ {</li>
<li class="old">   name = $1;</li>
<li class="old">   $1 = "";</li>
<li class="old">   if (name in prop) {</li>
<li class="old">      prop[name] = $0;</li>
<li class="old">      if (/^[ \t]*\{/) {</li>
<li class="old">         prop[name] = name count;</li>
<li class="old">         if (pass == "c1") print "static bool " prop[name] "(void) " $0;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (pass == "c2") {</li>
<li class="old">      print "#error \"" FILENAME " line " NR ": unknown attribute '" name "'\"";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">!obj &amp;&amp; pass == (/^#include/ ? "c1" : "h") {</li>
<li class="old">   print;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">END {</li>
<li class="old">   outputRecord("\n};");</li>
<li class="old">   if (pass == "h") {</li>
<li class="old">      print "\n#define endOfObjs\t(objs + " count ")";</li>
<li class="old">      print "\n#define validObject(obj)\t" \</li>
<li class="old">            "((obj) != NULL &amp;&amp; (*(obj)-&gt;condition)())";</li>
<li class="old">   }</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">function outputRecord(separator)</li>
<li class="old">{</li>
<li class="old">   if (obj) {</li>
<li class="old">      if (pass == "h") {</li>
<li class="old">         print "#define " obj "\t(objs + " count ")";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c1") {</li>
<li class="old">         print "static const char *tags" count "[] = {" prop["tags"] ", NULL};";</li>
<li class="old">      }</li>
<li class="old">      else if (pass == "c2") {</li>
<li class="old">         print "\t{\t/* " count " = " obj " */";</li>
<li class="old">         print "\t\t" prop["condition"] ",";</li>
<li class="old">         print "\t\t" prop["description"] ",";</li>
<li class="old">         print "\t\ttags" count ",";</li>
<li class="old">         print "\t\t" prop["location"] ",";</li>
<li class="old">         print "\t\t" prop["destination"] ",";</li>
<li class="old">         print "\t\t" prop[prop["prospect"] ? "prospect" : "destination"] ",";</li>
<li class="old">         print "\t\t" prop["details"] ",";</li>
<li class="old">         print "\t\t" prop["contents"] ",";</li>
<li class="old">         print "\t\t" prop["textGo"] ",";</li>
<li class="new">         print "\t\t" prop["gossip"] ",";</li>
<li class="old">         print "\t\t" prop["weight"] ",";</li>
<li class="old">         print "\t\t" prop["capacity"] ",";</li>
<li class="old">         print "\t\t" prop["health"] ",";</li>
<li class="old">         print "\t\t" prop["light"] ",";</li>
<li class="old">         print "\t\t" prop["open"] ",";</li>
<li class="old">         print "\t\t" prop["close"] ",";</li>
<li class="old">         print "\t\t" prop["lock"] ",";</li>
<li class="old">         print "\t\t" prop["unlock"];</li>
<li class="old">         print "\t}" separator;</li>
<li class="old">         delete prop;</li>
<li class="old">      }</li>
<li class="old">      count++;</li>
<li class="old">   }</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<p>
Adding a new command &lsquo;talk&rsquo; to the parser:
</p>
<table class="code"><tr>
<th>parsexec.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;ctype.h&gt;</li>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old">#include "match.h"</li>
<li class="old">#include "location.h"</li>
<li class="old">#include "inventory.h"</li>
<li class="old">#include "inventory2.h"</li>
<li class="old">#include "openclose.h"</li>
<li class="old">#include "onoff.h"</li>
<li class="new">#include "talk.h"</li>
<li class="old"></li>
<li class="old">typedef struct</li>
<li class="old">{</li>
<li class="old">   const char *pattern;</li>
<li class="old">   bool (*function)(void);</li>
<li class="old">} COMMAND;</li>
<li class="old"></li>
<li class="old">static bool executeQuit(void)</li>
<li class="old">{</li>
<li class="old">   return false;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static bool executeNoMatch(void)</li>
<li class="old">{</li>
<li class="old">   const char *src = *params;</li>
<li class="old">   if (*src != '\0')</li>
<li class="old">   {</li>
<li class="old">      printf("I don't know how to '");</li>
<li class="old">      while (*src != '\0' &amp;&amp; !isspace(*src)) putchar(*src++);</li>
<li class="old">      printf("'.\n");</li>
<li class="old">   }</li>
<li class="old">   return true;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">bool parseAndExecute(const char *input)</li>
<li class="old">{</li>
<li class="old">   static const COMMAND commands[] =</li>
<li class="old">   {</li>
<li class="old">      { "quit"                , executeQuit       },</li>
<li class="old">      { "look"                , executeLookAround },</li>
<li class="old">      { "look around"         , executeLookAround },</li>
<li class="old">      { "look at A"           , executeLook       },</li>
<li class="old">      { "look A"              , executeLook       },</li>
<li class="old">      { "examine A"           , executeLook       },</li>
<li class="old">      { "go to A"             , executeGo         },</li>
<li class="old">      { "go A"                , executeGo         },</li>
<li class="old">      { "get A from B"        , executeGetFrom    },</li>
<li class="old">      { "get A"               , executeGet        },</li>
<li class="old">      { "put A in B"          , executePutIn      },</li>
<li class="old">      { "drop A in B"         , executePutIn      },</li>
<li class="old">      { "drop A"              , executeDrop       },</li>
<li class="old">      { "ask A from B"        , executeAskFrom    },</li>
<li class="old">      { "ask A"               , executeAsk        },</li>
<li class="old">      { "give A to B"         , executeGiveTo     },</li>
<li class="old">      { "give A"              , executeGive       },</li>
<li class="old">      { "inventory"           , executeInventory  },</li>
<li class="old">      { "open A"              , executeOpen       },</li>
<li class="old">      { "close A"             , executeClose      },</li>
<li class="old">      { "lock A"              , executeLock       },</li>
<li class="old">      { "unlock A"            , executeUnlock     },</li>
<li class="old">      { "turn on A"           , executeTurnOn     },</li>
<li class="old">      { "turn off A"          , executeTurnOff    },</li>
<li class="old">      { "turn A on"           , executeTurnOn     },</li>
<li class="old">      { "turn A off"          , executeTurnOff    },</li>
<li class="new">      { "talk with B about A" , executeTalkTo     },</li>
<li class="new">      { "talk about A with B" , executeTalkTo     },</li>
<li class="new">      { "talk about A"        , executeTalk       },</li>
<li class="new">      { "talk A"              , executeTalk       },</li>
<li class="old">      { "A"                   , executeNoMatch    }</li>
<li class="old">   };</li>
<li class="old">   const COMMAND *cmd;</li>
<li class="old">   for (cmd = commands; !matchCommand(input, cmd-&gt;pattern); cmd++);</li>
<li class="old">   return (*cmd-&gt;function)();</li>
<li class="old">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 67-70:
four new patterns for one new verb.
As explained in chapter 14, the order of the patterns is important.
</li>
</ul>
</div>
<p>
As many times before, we introduce a new module to implement the new command:
</p>
<table class="code"><tr>
<th>talk.h</th>
</tr><tr>
<td>
<ol>
<li class="new">extern bool executeTalk(void);</li>
<li class="new">extern bool executeTalkTo(void);</li>
</ol>
</td>
</tr><tr>
<th>talk.c</th>
</tr><tr>
<td>
<ol>
<li class="new">#include &lt;stdbool.h&gt;</li>
<li class="new">#include &lt;stdio.h&gt;</li>
<li class="new">#include "object.h"</li>
<li class="new">#include "misc.h"</li>
<li class="new">#include "match.h"</li>
<li class="new">#include "noun.h"</li>
<li class="new">#include "reach.h"</li>
<li class="new"></li>
<li class="new">static void talk(const char *about, OBJECT *to)</li>
<li class="new">{</li>
<li class="new">   OBJECT *topic = getTopic(about);</li>
<li class="new">   if (topic == NULL)</li>
<li class="new">   {</li>
<li class="new">      printf("I don't understand what you want to talk about.\n");</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("You hear %s say: '%s'\n",</li>
<li class="new">             to-&gt;description,</li>
<li class="new">             topic == to ? "I don't want to talk about myself."</li>
<li class="new">                         : topic-&gt;gossip);</li>
<li class="new">   }</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool executeTalk(void)</li>
<li class="new">{</li>
<li class="new">   OBJECT *to = actorHere();</li>
<li class="new">   if (to != NULL)</li>
<li class="new">   {</li>
<li class="new">      talk(params[0], to);</li>
<li class="new">   }</li>
<li class="new">   else</li>
<li class="new">   {</li>
<li class="new">      printf("There is nobody here to talk to.\n");</li>
<li class="new">   }</li>
<li class="new">   return true;</li>
<li class="new">}</li>
<li class="new"></li>
<li class="new">bool executeTalkTo(void)</li>
<li class="new">{</li>
<li class="new">   OBJECT *to = reachableObject("who to talk to", params[1]);</li>
<li class="new">   if (to != NULL)</li>
<li class="new">   {</li>
<li class="new">      if (to-&gt;health &gt; 0)</li>
<li class="new">      {</li>
<li class="new">         talk(params[0], to);</li>
<li class="new">      }</li>
<li class="new">      else</li>
<li class="new">      {</li>
<li class="new">         printf("There is no response from %s.\n", to-&gt;description);</li>
<li class="new">      }</li>
<li class="new">   }</li>
<li class="new">   return true;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<p>
Function <i>getTopic</i> is implemented in one of the existing modules:
</p>
<table class="code"><tr>
<th>noun.h</th>
</tr><tr>
<td>
<ol>
<li class="old">extern OBJECT *getVisible(const char *intention, const char *noun);</li>
<li class="old">extern OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun);</li>
<li class="new">extern OBJECT *getTopic(const char *noun);</li>
</ol>
</td>
</tr><tr>
<th>noun.c</th>
</tr><tr>
<td>
<ol>
<li class="old">#include &lt;stdbool.h&gt;</li>
<li class="old">#include &lt;stdio.h&gt;</li>
<li class="old">#include &lt;string.h&gt;</li>
<li class="old">#include "object.h"</li>
<li class="old">#include "misc.h"</li>
<li class="old"></li>
<li class="old">static bool objectHasTag(OBJECT *obj, const char *noun)</li>
<li class="old">{</li>
<li class="old">   if (noun != NULL &amp;&amp; *noun != '\0')</li>
<li class="old">   {</li>
<li class="old">      const char **tag;</li>
<li class="old">      for (tag = obj-&gt;tags; *tag != NULL; tag++)</li>
<li class="old">      {</li>
<li class="old">         if (strcmp(*tag, noun) == 0) return true;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return false;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">static OBJECT ambiguousNoun;</li>
<li class="old"></li>
<li class="old">static OBJECT *getObject(const char *noun, OBJECT *from, DISTANCE maxDistance)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj, *res = NULL;</li>
<li class="old">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="old">   {</li>
<li class="old">      if (objectHasTag(obj, noun) &amp;&amp; getDistance(from, obj) &lt;= maxDistance)</li>
<li class="old">      {</li>
<li class="old">         res = res == NULL ? obj : &amp;ambiguousNoun;</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   return res;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">OBJECT *getVisible(const char *intention, const char *noun)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = getObject(noun, player, distOverthere);</li>
<li class="old">   if (obj == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (getObject(noun, player, distNotHere) == NULL)</li>
<li class="old">      {</li>
<li class="old">         printf("I don't understand %s.\n", intention);</li>
<li class="old">      }</li>
<li class="old">      else if (isLit(player-&gt;location))</li>
<li class="old">      {</li>
<li class="old">         printf("You don't see any %s here.\n", noun);</li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         printf("It's too dark.\n");</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (obj == &amp;ambiguousNoun)</li>
<li class="old">   {</li>
<li class="old">      printf("Please be specific about which %s you mean.\n", noun);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   return obj;</li>
<li class="old">}</li>
<li class="old"></li>
<li class="old">OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun)</li>
<li class="old">{</li>
<li class="old">   OBJECT *obj = NULL;</li>
<li class="old">   if (from == NULL)</li>
<li class="old">   {</li>
<li class="old">      printf("I don't understand who you want to %s.\n", verb);</li>
<li class="old">   }</li>
<li class="old">   else if ((obj = getObject(noun, from, distHeldContained)) == NULL)</li>
<li class="old">   {</li>
<li class="old">      if (getObject(noun, player, distNotHere) == NULL)</li>
<li class="old">      {</li>
<li class="old">         printf("I don't understand what you want to %s.\n", verb);</li>
<li class="old">      }</li>
<li class="old">      else if (from == player)</li>
<li class="old">      {</li>
<li class="old">         printf("You are not holding any %s.\n", noun);</li>
<li class="old">      }</li>
<li class="old">      else</li>
<li class="old">      {</li>
<li class="old">         printf("There appears to be no %s you can get from %s.\n",</li>
<li class="old">                noun, from-&gt;description);</li>
<li class="old">      }</li>
<li class="old">   }</li>
<li class="old">   else if (obj == &amp;ambiguousNoun)</li>
<li class="old">   {</li>
<li class="old">      printf("Please be specific about which %s you want to %s.\n",</li>
<li class="old">             noun, verb);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   else if (obj == from)</li>
<li class="old">   {</li>
<li class="old">      printf("You should not be doing that to %s.\n", obj-&gt;description);</li>
<li class="old">      obj = NULL;</li>
<li class="old">   }</li>
<li class="old">   return obj;</li>
<li class="old">}</li>
<li class="new"></li>
<li class="new">OBJECT *getTopic(const char *noun)</li>
<li class="new">{</li>
<li class="new">   OBJECT *obj;</li>
<li class="new">   for (obj = objs; obj &lt; endOfObjs; obj++)</li>
<li class="new">   {</li>
<li class="new">      if (objectHasTag(obj, noun)) return obj;</li>
<li class="new">   }</li>
<li class="new">   return NULL;</li>
<li class="new">}</li>
</ol>
</td>
</tr></table>
<div class="explanation">
<p>
Explanation:
</p>
<ul>
<li>Line 98-106:
&lsquo;talk&rsquo; is one of the few commands that can be applied to an object
that is not present; that you may not even have seen yet. Therefore,
function <i>getTopic</i> is not interested in the object&rsquo;s distance.
It will return whatever object it can find with the given tag.
</li>
</ul>
</div>
<p>
And if you cannot talk your way out of a difficult situation,
then there is always the option to use physical force.
More on that in the following chapter.
</p>
<hr />
<table class="download"><tr><td>
<a class="button" href="code19/src.zip">&#x2B73; &nbsp; Download source code</a>
<a class="button" href="https://repl.it/github/helderman/htpataic">&#x1F300; &nbsp; Run on Repl.it</a>
</td></tr></table>
<p>
Next chapter: <a href="htpataic20.html">20. Combat</a>
</p>
</body>
</html>
